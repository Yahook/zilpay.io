Project Path: zilpay.io

Source Tree:

```txt
zilpay.io
├── components
│   ├── account-card
│   │   └── index.tsx
│   ├── footer
│   │   └── index.tsx
│   ├── icons
│   │   ├── apple.tsx
│   │   ├── arrow.tsx
│   │   ├── back.tsx
│   │   ├── chrome.tsx
│   │   ├── close.tsx
│   │   ├── copy.tsx
│   │   ├── email.tsx
│   │   ├── firefox.tsx
│   │   ├── github.tsx
│   │   ├── google.tsx
│   │   ├── linkedin.tsx
│   │   ├── medium.tsx
│   │   ├── reject.tsx
│   │   ├── safari.tsx
│   │   ├── success.tsx
│   │   ├── swap.tsx
│   │   ├── telegram.tsx
│   │   ├── twitter.tsx
│   │   └── view.tsx
│   ├── info-card
│   │   └── index.tsx
│   ├── modal
│   │   └── index.tsx
│   ├── modals
│   │   ├── account
│   │   │   └── index.tsx
│   │   ├── add-pool-preview
│   │   │   └── index.tsx
│   │   ├── confirm-swap
│   │   │   └── index.tsx
│   │   ├── settings
│   │   │   └── index.tsx
│   │   └── tokens
│   │       └── index.tsx
│   ├── nav-bar
│   │   └── index.tsx
│   ├── pair-img
│   │   └── index.tsx
│   ├── pool
│   │   ├── add-pool
│   │   │   └── index.tsx
│   │   ├── index.ts
│   │   ├── pools-overview
│   │   │   └── index.tsx
│   │   └── remove-pool
│   │       └── index.tsx
│   ├── price-info
│   │   └── index.tsx
│   ├── smart-button
│   │   └── index.tsx
│   ├── swap-form
│   │   ├── form.tsx
│   │   ├── index.ts
│   │   ├── input
│   │   │   └── index.tsx
│   │   └── settings
│   │       └── index.tsx
│   ├── toggle
│   │   └── index.tsx
│   ├── tx-card
│   │   └── index.tsx
│   └── zilpay-connect
│       └── index.tsx
├── config
│   ├── conts.ts
│   ├── links.ts
│   ├── storage-fields.ts
│   └── themes.ts
├── filters
│   ├── n-format.ts
│   └── n-pool.ts
├── lib
│   ├── chunk.ts
│   ├── compact.ts
│   ├── parse-init.ts
│   ├── to-hex.ts
│   ├── trim.ts
│   └── viewblock.ts
├── mixins
│   ├── backend.ts
│   ├── custom-fetch.ts
│   ├── dex.ts
│   ├── token.ts
│   └── zilpay-base.ts
├── next-env.d.ts
├── pages
│   ├── _app.tsx
│   ├── _document.tsx
│   ├── dex-policy.tsx
│   ├── extension-policy.tsx
│   ├── index.tsx
│   ├── policy.tsx
│   ├── pool
│   │   ├── [addr].tsx
│   │   ├── add.tsx
│   │   └── index.tsx
│   ├── swap.tsx
│   └── terms.tsx
├── store
│   ├── dex.ts
│   ├── netwrok.ts
│   ├── settings.ts
│   ├── shares.ts
│   ├── tokens.ts
│   ├── transactions.ts
│   └── wallet.ts
└── types
    ├── index.d.ts
    ├── swap.d.ts
    ├── token.d.ts
    ├── wallet.d.ts
    └── zilliqa.d.ts

```

`zilpay.io/components/account-card/index.tsx`:

```tsx
import styles from "./index.module.scss";

import React from "react";
import copy from "clipboard-copy";
import { Wallet } from '@/types/wallet';

import { useTranslation } from "next-i18next";

import { CopyIcon } from "components/icons/copy";
import { ViewIcon } from "components/icons/view";

import { trim } from "@/lib/trim";
import { viewAddress } from "@/lib/viewblock";
import { useStore } from "react-stores";
import { $net } from "@/store/netwrok";


type Prop = {
  wallet: Wallet | null;
};

export var AccountCard: React.FC<Prop> = function ({ wallet }) {
  const common = useTranslation(`common`);

  const { net } = useStore($net);

  return (
    <div className={styles.container}>
      <p>
        {common.t(`connected_via`)}
        {` `}
        {net}
        .
      </p>
      <h4>
        {wallet ? trim(wallet.bech32, 15) : ``}
      </h4>
      <div className={styles.row}>
        <div
          className={styles.copy}
          onClick={() => copy(String(wallet?.bech32))}
        >
          <CopyIcon />
          <p>
            {common.t(`copy_adr`)}
          </p>
        </div>
        <a
          className={styles.second}
          href={wallet ? viewAddress(String(wallet?.bech32)) : ``}
          target="_blank"
          rel="noopener noreferrer"
        >
          <ViewIcon />
          <p>
            {common.t(`view_explorer`)}
          </p>
        </a>
      </div>
    </div>
  );
};

```

`zilpay.io/components/footer/index.tsx`:

```tsx
import styles from "./index.module.scss";

import { useTranslation } from 'next-i18next';
import React from 'react';
import Link from 'next/link';

import AppleIcon from "@/components/icons/apple";
import ChromeIcon from "@/components/icons/chrome";
import EmailIcon from "@/components/icons/email";
import FireFoxIcon from "@/components/icons/firefox";
import GitHubIcon from "@/components/icons/github";
import GoogleIcon from "@/components/icons/google";
import MediumIcon from "@/components/icons/medium";
import TelegramIcon from "@/components/icons/telegram";
import TwitterIcon from "@/components/icons/twitter";

import SafariIcon from "../icons/safari";
import { AppLinks } from "@/config/links";

export const Footer: React.FC = () => {
  const { t } = useTranslation(`common`);

  return (
  <div className={styles.container}>
      <div className={styles.wrapper}>
        <div className={styles.office}>
          <h3>
            {t(`office`)}
          </h3>
          <p>
            {t(`office_value`)}
          </p>
        </div>
        <div className={styles.involved}>
          <h3>
            {t(`footer_icons`)}
          </h3>
          <div>
            <a
              href={AppLinks.SAFARI}
              target="_blank"
              rel="noopener noreferrer"
            >
              <SafariIcon
                color="var(--text-color)"
                height="27"
                width="27"
              />
            </a>
            <a
              href={AppLinks.IOS}
              target="_blank"
              rel="noopener noreferrer"
            >
              <AppleIcon
                color="var(--text-color)"
                height="30"
                width="30"
              />
            </a>
            <a
              href={AppLinks.GOOGLE}
              target="_blank"
              rel="noopener noreferrer"
            >
              <GoogleIcon
                color="var(--text-color)"
                height="30"
                width="30"
              />
            </a>
            <a
              href={AppLinks.FIREFOX}
              target="_blank"
              rel="noopener noreferrer"
            >
              <FireFoxIcon
                color="var(--text-color)"
                height="30"
                width="30"
              />
            </a>
            <a
              href={AppLinks.CHROME}
              target="_blank"
              rel="noopener noreferrer"
            >
              <ChromeIcon
                color="var(--text-color)"
                height="30"
                width="30"
              />
            </a>
            <a
              href="https://t.me/zilpaychat"
              target="_blank"
              rel="noopener noreferrer"
            >
              <TelegramIcon
                color="var(--text-color)"
                height="30"
                width="30"
              />
            </a>
            <a
              href="https://twitter.com/pay_zil"
              target="_blank"
              rel="noopener noreferrer"
            >
              <TwitterIcon
                color="var(--text-color)"
                height="30"
                width="30"
              />
            </a>
            <a
              href="mailto:contact@zilpay.io"
              target="_blank"
              rel="noopener noreferrer"
            >
              <EmailIcon
                color="var(--text-color)"
                height="30"
                width="30"
              />
            </a>
            <a
              href="https://github.com/zilpay"
              target="_blank"
              rel="noopener noreferrer"
            >
              <GitHubIcon
                color="var(--text-color)"
                height="30"
                width="30"
              />
            </a>
            <a
              href="https://medium.com/@lich666black"
              target="_blank"
              rel="noopener noreferrer"
            >
              <MediumIcon
                color="var(--text-color)"
                height="30"
                width="30"
              />
            </a>
          </div>
        </div>
        <div className={styles.legal}>
          <h3>
            {t(`legal`)}
          </h3>
          <Link href="/terms" passHref>
            <p className={styles.pointer}>
              {t(`terms`)}
            </p>
          </Link>
          <Link href="/policy" passHref>
            <p className={styles.pointer}>
              {t(`privacy`)}
            </p>
          </Link>
          <Link href="/extension-policy" passHref>
            <p className={styles.pointer}>
              {t(`extension-policy`)}
            </p>
          </Link>
          <Link href="/dex-policy" passHref>
            <p className={styles.pointer}>
              {t(`dex-policy`)}
            </p>
          </Link>
          <a
            href="https://zilpay.github.io/zilpay-docs/"
            target="_blanck"
          >
            <p className={styles.pointer}>
              Documentation
            </p>
          </a>
        </div>
      </div>
    </div>
  );
};

```

`zilpay.io/components/icons/apple.tsx`:

```tsx
import React from 'react';

type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const AppleIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path
        d="M22 17.607C21.214 19.887 18.861 23.924 16.437 23.968C14.829 23.999 14.312 23.015 12.474 23.015C10.637 23.015 10.062 23.938 8.542 23.998C5.97 24.097 2 18.171 2 13.003C2 8.256 5.308 5.903 8.198 5.86C9.748 5.832 11.212 6.905 12.157 6.905C13.106 6.905 14.884 5.615 16.753 5.804C17.535 5.837 19.732 6.119 21.142 8.181C17.401 10.623 17.984 15.73 22 17.607ZM16.778 0C13.952 0.114 11.646 3.079 11.968 5.531C14.58 5.734 17.086 2.806 16.778 0Z"
        fill={hoverd ? hoverColor : color}
      />
    </svg>
  );
};

export default AppleIcon;

```

`zilpay.io/components/icons/arrow.tsx`:

```tsx
import React from 'react';

type Prop = {
  width?: number | string;
  height?: number | string;
  color: string;
};

const ArrowIcon: React.FC<Prop> = ({
  width = 24,
  height = 24,
  color
}) => {
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      stroke={color}
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <polyline points="6 9 12 15 18 9" />
    </svg>
  );
};

export default ArrowIcon;

```

`zilpay.io/components/icons/back.tsx`:

```tsx
import React from "react";

type Prop = {
  color?: string;
  width?: number | string;
  height?: number | string;
};

export var BackIcon: React.FC<Prop> = function ({
  color = 'var(--text-color)',
  width = 24,
  height = 24
}) {
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      stroke={color}
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <line x1="19" y1="12" x2="5" y2="12"/>
      <polyline points="12 19 5 12 12 5"/>
    </svg>
  );
};

```

`zilpay.io/components/icons/chrome.tsx`:

```tsx
import React from 'react';

type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const ChromeIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <g clipPath="url(#clip0)">
        <path
          d="M2.897 4.181C5.327 1.353 8.66 0 11.969 0C16.257 0 20.504 2.273 22.686 6.554C19.964 6.555 15.702 6.554 13.393 6.554C11.719 6.555 10.638 6.517 9.467 7.133C8.091 7.857 7.052 9.2 6.69 10.777L2.897 4.181V4.181ZM8.007 12C8.007 14.2 9.796 15.99 11.995 15.99C14.194 15.99 15.983 14.2 15.983 12C15.983 9.8 14.194 8.009 11.995 8.009C9.796 8.009 8.007 9.8 8.007 12ZM13.543 17.223C11.305 17.889 8.685 17.15 7.25 14.674C6.155 12.783 3.261 7.741 1.945 5.449C0.615 7.489 0 9.743 0 11.956C0 17.404 3.726 22.606 9.673 23.774L13.543 17.223ZM15.701 8.009C17.565 9.743 17.972 12.551 16.708 14.728C15.757 16.369 12.72 21.494 11.248 23.976C18.437 24.419 24 18.616 24 12.004C24 10.691 23.78 9.344 23.31 8.009H15.701V8.009Z"
          fill={hoverd ? hoverColor : color}
        />
      </g>
      <defs>
        <clipPath id="clip0">
        <rect
          width={width}
          height={height}
          fill="none"
        />
        </clipPath>
      </defs>
    </svg>
  );
};
export default ChromeIcon;

```

`zilpay.io/components/icons/close.tsx`:

```tsx
import React from "react";

type Prop = {
  color?: string;
  width?: number | string;
  height?: number | string;
};

export var CloseIcon: React.FC<Prop> = function ({
  color = 'var(--primary-color)',
  width = 20,
  height = 20
}) {
  return (
    <svg width={width} height={height} viewBox="0 0 26 26" fill="none">
      <path
        d="M1.68555 1.68652L24.313 24.3139"
        stroke={color}
        strokeWidth="2"
      />
      <path
        d="M1.6875 24.3135L24.3149 1.68606"
        stroke={color}
        strokeWidth="2"
      />
    </svg>
  );
};

```

`zilpay.io/components/icons/copy.tsx`:

```tsx
import React from "react";

type Prop = {
  color?: string;
  width?: number | string;
  height?: number | string;
};

export var CopyIcon: React.FC<Prop> = function ({
  color = 'var(--muted-color)',
  width = 16,
  height = 16,
}) {
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      stroke={color}
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <rect x="9" y="9" width="13" height="13" rx="2" ry="2" />
      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
    </svg>
  );
};

```

`zilpay.io/components/icons/email.tsx`:

```tsx
import React from 'react';

type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const EmailIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path
        d="M12 12.713L0.015 3H23.986L12 12.713ZM6.575 10.891L0 5.562V18.063L6.575 10.891ZM17.425 10.891L24 18.063V5.562L17.425 10.891ZM15.868 12.152L12 15.287L8.132 12.152L0.022 21H23.978L15.868 12.152V12.152Z"
        fill={hoverd ? hoverColor : color}
      />
    </svg>
  );
};

export default EmailIcon;

```

`zilpay.io/components/icons/firefox.tsx`:

```tsx
import React from 'react';

type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const FireFoxIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path
        d="M12 0C5.373 0 0 5.373 0 12C0 18.627 5.373 24 12 24C18.627 24 24 18.627 24 12C24 5.373 18.627 0 12 0ZM20.003 8.657C18.727 5.336 15.543 4.052 14.469 4.12C17.998 5.496 18.842 10.179 18.529 11.561C18.222 9.94 17.243 8.544 16.657 8.176C20.074 16.181 11.822 18.641 9.304 15.863C9.953 16.031 11.235 15.948 12.195 15.306C13.093 14.704 13.178 14.668 13.755 14.623C14.441 14.57 13.714 13.217 12.216 13.446C11.6 13.54 10.584 14.265 9.336 13.787C7.828 13.211 7.876 11.153 9.432 11.772C9.769 11.335 9.52 10.509 9.52 10.509C9.972 10.095 10.542 9.803 10.89 9.598C11.118 9.463 11.719 9.091 11.685 8.368C11.562 8.272 11.365 8.149 10.919 8.175C9.183 8.285 9.067 7.657 8.952 7.367C9.03 6.699 9.476 5.833 10.313 5.436C9.056 5.243 8.033 5.833 7.524 6.59C6.715 6.416 6.219 6.407 5.406 6.559C5.09 6.319 4.74 5.889 4.528 5.378C6.36 3.312 9.027 2 12 2C17.912 2 20.263 6.283 20.003 8.657Z"
        fill={hoverd ? hoverColor : color}
      />
    </svg>
  );
};

export default FireFoxIcon;

```

`zilpay.io/components/icons/github.tsx`:

```tsx
import React from 'react';

type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const GitHubIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 33 33"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path d="M16.0542 0C7.18887 0 0 7.36944 0 16.4605C0 23.7332 4.60001 29.9033 10.9788 32.0798C11.7812 32.2322 12.0757 31.7227 12.0757 31.288C12.0757 30.8955 12.0608 29.5988 12.0539 28.2234C7.58764 29.2191 6.6452 26.2812 6.6452 26.2812C5.91491 24.3786 4.86267 23.8727 4.86267 23.8727C3.40608 22.8511 4.97247 22.8721 4.97247 22.8721C6.58459 22.9882 7.43345 24.5684 7.43345 24.5684C8.86532 27.0848 11.1891 26.3573 12.1052 25.9367C12.2493 24.8728 12.6654 24.1467 13.1245 23.7356C9.55866 23.3194 5.81016 21.908 5.81016 15.6008C5.81016 13.8037 6.43731 12.3353 7.46429 11.1826C7.2976 10.768 6.74809 9.09378 7.61981 6.82647C7.61981 6.82647 8.96794 6.38407 12.0359 8.51373C13.3165 8.14902 14.6898 7.96612 16.0542 7.95985C17.4185 7.96612 18.793 8.14902 20.076 8.51373C23.1402 6.38407 24.4864 6.82647 24.4864 6.82647C25.3603 9.09378 24.8105 10.768 24.6438 11.1826C25.6732 12.3353 26.2961 13.8037 26.2961 15.6008C26.2961 21.923 22.5404 23.315 18.9655 23.7225C19.5413 24.2334 20.0544 25.2351 20.0544 26.7708C20.0544 28.9732 20.0358 30.7458 20.0358 31.288C20.0358 31.726 20.3248 32.2393 21.1386 32.0776C27.5139 29.8986 32.1081 23.7307 32.1081 16.4605C32.1081 7.36944 24.9203 0 16.0542 0Z" fill={hoverd ? hoverColor : color}/>
      <path d="M6.12837 23.5205C6.09308 23.6015 5.96783 23.6258 5.85373 23.5702C5.7375 23.517 5.67222 23.4066 5.7099 23.3254C5.7444 23.242 5.86991 23.2188 5.98588 23.2746C6.10237 23.3278 6.16871 23.4393 6.12837 23.5205Z" fill={hoverd ? hoverColor : color}/>
      <path d="M6.77677 24.2566C6.70035 24.3287 6.55095 24.2952 6.44959 24.1813C6.34477 24.0677 6.32514 23.9157 6.40262 23.8426C6.48143 23.7705 6.62631 23.8043 6.7314 23.9179C6.83621 24.0329 6.85664 24.1837 6.77677 24.2566Z" fill={hoverd ? hoverColor : color}/>
      <path d="M7.4079 25.1962C7.30972 25.2655 7.14918 25.2005 7.04994 25.0556C6.95175 24.9106 6.95175 24.7368 7.05206 24.6672C7.15157 24.5975 7.30972 24.6602 7.41029 24.804C7.50821 24.9514 7.50821 25.1252 7.4079 25.1962Z" fill={hoverd ? hoverColor : color}/>
      <path d="M8.2744 26.1024C8.18657 26.2009 7.99949 26.1744 7.86257 26.04C7.72246 25.9086 7.68345 25.7221 7.77155 25.6236C7.86044 25.5248 8.04858 25.5526 8.18657 25.6859C8.32561 25.8171 8.36807 26.0049 8.2744 26.1024Z" fill={hoverd ? hoverColor : color}/>
      <path d="M9.46912 26.6294C9.43038 26.7571 9.2502 26.8151 9.0687 26.7608C8.88746 26.705 8.76885 26.5555 8.80547 26.4265C8.84315 26.298 9.02412 26.2375 9.20695 26.2956C9.38792 26.3512 9.5068 26.4996 9.46912 26.6294Z" fill={hoverd ? hoverColor : color}/>
      <path d="M10.7804 26.7271C10.7849 26.8615 10.631 26.973 10.4405 26.9754C10.2489 26.9797 10.0939 26.871 10.0918 26.7387C10.0918 26.603 10.2423 26.4926 10.4338 26.4894C10.6244 26.4856 10.7804 26.5935 10.7804 26.7271Z" fill={hoverd ? hoverColor : color}/>
      <path d="M11.9996 26.5155C12.0224 26.6466 11.89 26.7813 11.7008 26.8172C11.5148 26.8517 11.3426 26.7708 11.319 26.6407C11.2959 26.5063 11.4307 26.3716 11.6164 26.3368C11.8059 26.3033 11.9755 26.3821 11.9996 26.5155Z" fill={hoverd ? hoverColor : color}/>
    </svg>
  );
};

export default GitHubIcon;

```

`zilpay.io/components/icons/google.tsx`:

```tsx
import React from 'react';

type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const GoogleIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path d="M3 22V2L21 12L3 22Z" fill={hoverd ? hoverColor : color}/>
    </svg>
  );
};

export default GoogleIcon;

```

`zilpay.io/components/icons/linkedin.tsx`:

```tsx
import React from 'react';

type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const LinkedinIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path d="M19 0H5C2.239 0 0 2.239 0 5V19C0 21.761 2.239 24 5 24H19C21.762 24 24 21.761 24 19V5C24 2.239 21.762 0 19 0ZM8 19H5V8H8V19ZM6.5 6.732C5.534 6.732 4.75 5.942 4.75 4.968C4.75 3.994 5.534 3.204 6.5 3.204C7.466 3.204 8.25 3.994 8.25 4.968C8.25 5.942 7.467 6.732 6.5 6.732ZM20 19H17V13.396C17 10.028 13 10.283 13 13.396V19H10V8H13V9.765C14.396 7.179 20 6.988 20 12.241V19Z" fill={hoverd ? hoverColor : color}/>
    </svg>
  );
};

export default LinkedinIcon;

```

`zilpay.io/components/icons/medium.tsx`:

```tsx
import React from 'react';


type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const MediumIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M19 24H5C2.239 24 0 21.761 0 19V5C0 2.239 2.239 0 5 0H19C21.762 0 24 2.239 24 5V19C24 21.761 21.763 23.999 19 24ZM19.97 18.351V18.082L18.723 16.858C18.613 16.774 18.558 16.636 18.581 16.499V7.501C18.558 7.364 18.613 7.226 18.723 7.142L20 5.918V5.649H15.578L12.426 13.512L8.84 5.649H4.202V5.918L5.696 7.717C5.842 7.85 5.917 8.044 5.897 8.24V15.312C5.941 15.567 5.86 15.828 5.681 16.014L4 18.052V18.321H8.766V18.052L7.085 16.014C6.904 15.828 6.819 15.569 6.853 15.312V9.196L11.036 18.321H11.522L15.115 9.196V16.469C15.115 16.663 15.115 16.701 14.988 16.828L13.696 18.082V18.351H19.97V18.351Z"
        fill={hoverd ? hoverColor : color}
      />
    </svg>
  );
};

export default MediumIcon;

```

`zilpay.io/components/icons/reject.tsx`:

```tsx
import React from "react";


type Prop = {
  color?: string;
  width?: number | string;
  height?: number | string;
};

export var RejectIcon: React.FC<Prop> = function ({
  color = 'var(--danger-color)',
  width = 16,
  height = 16,
}) {
  return (
    <svg width={width} height={height} viewBox="0 0 20 20" fill="none">
      <path
        d="M10 0C4.489 0 0 4.489 0 10C0 15.511 4.489 20 10 20C15.511 20 20 15.511 20 10C20 4.489 15.511 0 10 0ZM10 2C14.4301 2 18 5.56988 18 10C18 11.8531 17.3693 13.5506 16.3184 14.9043L5.0957 3.68164C6.44944 2.63074 8.14693 2 10 2ZM3.68164 5.0957L14.9043 16.3184C13.5506 17.3693 11.8531 18 10 18C5.56988 18 2 14.4301 2 10C2 8.14693 2.63074 6.44944 3.68164 5.0957Z"
        fill={color}
      />
    </svg>
  );
};

```

`zilpay.io/components/icons/safari.tsx`:

```tsx
import React from 'react';

type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const SafariIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 32 32"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path
        d="M16 32c-8.839 0-16-7.161-16-16s7.161-16 16-16c8.839 0 16 7.161 16 16s-7.161 16-16 16zM16 31c8.286 0 15-6.714 15-15s-6.714-15-15-15c-8.286 0-15 6.714-15 15s6.714 15 15 15zM16 2.667c0.182 0 0.333 0.151 0.333 0.333v1.333c0 0.443-0.667 0.443-0.667 0v-1.333c0-0.182 0.151-0.333 0.333-0.333zM16 27.333c0.182 0 0.333 0.151 0.333 0.333v1.333c0 0.443-0.667 0.443-0.667 0v-1.333c0-0.182 0.151-0.333 0.333-0.333zM25.427 6.573c0.13 0.13 0.13 0.339 0 0.469l-0.943 0.943c-0.313 0.318-0.786-0.156-0.469-0.469l0.943-0.943c0.13-0.13 0.339-0.13 0.469 0zM7.984 24.016c0.135 0.13 0.135 0.339 0 0.469l-0.943 0.943c-0.125 0.146-0.349 0.151-0.484 0.016s-0.13-0.359 0.016-0.484l0.943-0.943c0.13-0.135 0.339-0.135 0.469 0zM6.573 6.573c0.13-0.13 0.339-0.13 0.469 0l0.943 0.943c0.318 0.313-0.156 0.786-0.469 0.474l-0.943-0.948c-0.13-0.13-0.13-0.339 0-0.469zM24.016 24.016c0.13-0.135 0.339-0.135 0.469 0l0.943 0.943c0.146 0.125 0.151 0.349 0.016 0.484s-0.359 0.13-0.484-0.016l-0.943-0.943c-0.135-0.13-0.135-0.339 0-0.469zM2.667 16c0-0.182 0.151-0.333 0.333-0.333h1.333c0.443 0 0.443 0.667 0 0.667h-1.333c-0.182 0-0.333-0.151-0.333-0.333zM27.333 16c0-0.182 0.151-0.333 0.333-0.333h1.333c0.443 0 0.443 0.667 0 0.667h-1.333c-0.182 0-0.333-0.151-0.333-0.333zM21.208 3.729c0.172 0.068 0.25 0.266 0.177 0.432l-0.521 1.229c-0.068 0.177-0.266 0.26-0.443 0.188-0.172-0.073-0.25-0.276-0.172-0.448l0.521-1.224c0.073-0.172 0.271-0.25 0.438-0.177zM11.573 26.432c0.167 0.073 0.25 0.266 0.177 0.438l-0.521 1.224c-0.182 0.391-0.766 0.141-0.615-0.255l0.521-1.229c0.073-0.172 0.266-0.25 0.438-0.177zM28.365 11.005c0.068 0.167-0.016 0.365-0.188 0.432l-1.234 0.5c-0.172 0.068-0.365-0.016-0.432-0.182-0.073-0.172 0.010-0.37 0.182-0.438l1.234-0.5c0.172-0.068 0.365 0.016 0.438 0.188zM5.49 20.245c0.073 0.172-0.010 0.365-0.182 0.432l-1.234 0.5c-0.172 0.078-0.375-0.005-0.448-0.177-0.068-0.177 0.021-0.375 0.198-0.438l1.234-0.5c0.172-0.073 0.365 0.010 0.432 0.182zM11.005 3.635c0.172-0.068 0.365 0.016 0.432 0.188l0.5 1.234c0.167 0.411-0.448 0.661-0.62 0.25l-0.495-1.234c-0.073-0.172 0.010-0.365 0.182-0.438zM20.245 26.51c0.172-0.073 0.365 0.010 0.438 0.182l0.495 1.234c0.078 0.172-0.005 0.375-0.177 0.448-0.177 0.068-0.375-0.021-0.438-0.198l-0.5-1.234c-0.073-0.172 0.010-0.365 0.182-0.432zM3.729 10.792c0.068-0.172 0.266-0.25 0.432-0.177l1.229 0.521c0.385 0.182 0.141 0.766-0.26 0.615l-1.224-0.521c-0.172-0.073-0.25-0.271-0.177-0.438zM26.432 20.427c0.073-0.167 0.266-0.245 0.438-0.177l1.224 0.521c0.177 0.068 0.266 0.271 0.193 0.443s-0.281 0.25-0.448 0.172l-1.229-0.521c-0.172-0.073-0.25-0.266-0.177-0.438zM17.172 17.172l-2.344-2.344-5.521 7.865zM25.427 6.573l-7.776 11.078-11.078 7.776 7.776-11.078z"
        fill={hoverd ? hoverColor : color}
      />
    </svg>
  );
};

export default SafariIcon;

```

`zilpay.io/components/icons/success.tsx`:

```tsx
import React from "react";

type Prop = {
  color?: string;
  width?: number | string;
  height?: number | string;
};

export var SuccessIcon: React.FC<Prop> = function ({
  color = 'var(--success-color)',
  width = 16,
  height = 16,
}) {
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      stroke={color}
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
      <polyline points="22 4 12 14.01 9 11.01" />
    </svg>
  );
};

```

`zilpay.io/components/icons/swap.tsx`:

```tsx
import React from 'react';


type Prop = {
  width?: number | string;
  height?: number | string;
  onClick?: () => void;
};

const SwapIcon: React.FC<Prop> = ({
  width = 32,
  height = 33,
  onClick
}) => {
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 32 33"
      fill="none"
      onClick={onClick}
    >
      <rect
        width="32"
        height="32"
        transform="translate(0 0.5)"
        fill="var(--button-color)"
      />
      <path
        d="M23.1595 13.2071L22.0151 12.0628L22.0151 21.1685L20.0151 21.1685L20.0151 11.8904L18.6984 13.2071L17.2842 11.7929L20.9289 8.14813L24.5737 11.7929L23.1595 13.2071Z"
        fill="var(--text-color)"
      />
      <path
        d="M9.95549 21.071L8.63875 19.7543L7.22454 21.1685L10.8693 24.8133L14.514 21.1685L13.0998 19.7543L11.9555 20.8986L11.9555 11.7929L9.9555 11.7929L9.95549 21.071Z"
        fill="var(--text-color)"
      />
    </svg>
  );
};

export default SwapIcon;

```

`zilpay.io/components/icons/telegram.tsx`:

```tsx
import React from 'react';


type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const TelegramIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M12 0C5.374 0 0 5.372 0 12C0 18.627 5.374 24 12 24C18.627 24 24 18.627 24 12C24 5.372 18.627 0 12 0ZM15.224 17.871C15.412 18.004 15.654 18.037 15.87 17.956C16.085 17.874 16.244 17.689 16.292 17.465C16.799 15.083 18.029 9.053 18.49 6.887C18.525 6.723 18.467 6.553 18.339 6.444C18.21 6.335 18.032 6.304 17.874 6.362C15.428 7.268 7.895 10.094 4.816 11.233C4.621 11.306 4.494 11.493 4.5 11.7C4.507 11.906 4.646 12.085 4.846 12.145C6.227 12.558 8.039 13.133 8.039 13.133C8.039 13.133 8.886 15.691 9.327 16.991C9.383 17.155 9.511 17.283 9.679 17.327C9.848 17.371 10.027 17.325 10.153 17.206C10.862 16.537 11.958 15.502 11.958 15.502C11.958 15.502 14.042 17.029 15.224 17.871V17.871ZM8.801 12.809L9.781 16.04L9.999 13.994C9.999 13.994 13.782 10.581 15.94 8.636C16.003 8.579 16.011 8.483 15.959 8.416C15.907 8.349 15.811 8.333 15.74 8.379C13.24 9.975 8.801 12.809 8.801 12.809V12.809Z"
        fill={hoverd ? hoverColor : color}
      />
    </svg>
  );
};

export default TelegramIcon;

```

`zilpay.io/components/icons/twitter.tsx`:

```tsx
import React from 'react';

type Prop = {
  width: number | string;
  height: number | string;
  color: string;
  hoverColor?: string;
};

const TwitterIcon: React.FC<Prop> = ({
  width,
  height,
  color,
  hoverColor = 'var(--primary-color)'
}) => {
  const [hoverd, setHover] = React.useState(false);
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 33 33"
      fill="none"
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      <path
        fillRule="evenodd"
        clipRule="evenodd"
        d="M16.9466 0C8.08022 0 0.892578 7.18764 0.892578 16.0541C0.892578 24.9205 8.08022 32.1081 16.9466 32.1081C25.813 32.1081 33.0007 24.9205 33.0007 16.0541C33.0007 7.18764 25.813 0 16.9466 0ZM17.7119 12.992L17.6698 12.2977C17.5437 10.4979 18.651 8.85408 20.4031 8.21638C21.0478 7.98965 22.1411 7.96131 22.856 8.1597C23.1363 8.24473 23.6689 8.52815 24.0474 8.78323L24.7342 9.25087L25.4911 9.00996C25.9116 8.88243 26.4723 8.66986 26.7246 8.52815C26.9628 8.40061 27.1731 8.32975 27.1731 8.37227C27.1731 8.61318 26.6545 9.4351 26.22 9.88857C25.6313 10.5263 25.7995 10.583 26.9909 10.1578C27.7057 9.91691 27.7197 9.91691 27.5796 10.1862C27.4955 10.3279 27.061 10.8239 26.5984 11.2773C25.8135 12.0567 25.7714 12.1418 25.7714 12.7936C25.7714 13.7998 25.2949 15.8971 24.8183 17.045C23.9353 19.199 22.043 21.4238 20.1508 22.5434C17.4876 24.1163 13.9414 24.5131 10.9559 23.592C9.96071 23.2802 8.25069 22.4867 8.25069 22.345C8.25069 22.3024 8.7693 22.2458 9.40005 22.2316C10.7176 22.2032 12.0352 21.8348 13.1565 21.1829L13.9134 20.7295L13.0444 20.4319C11.8109 20.0067 10.7036 19.0289 10.4233 18.1078C10.3392 17.8102 10.3672 17.796 11.1521 17.796L11.9651 17.7819L11.2783 17.4559C10.4653 17.045 9.72243 16.3506 9.358 15.642C9.09168 15.1319 8.75528 13.8423 8.8534 13.7431C8.88143 13.7006 9.17578 13.7856 9.51218 13.899C10.4793 14.2533 10.6055 14.1682 10.0448 13.5731C8.99357 12.4961 8.67118 10.8947 9.17578 9.37841L9.41406 8.6982L10.3392 9.61932C12.2314 11.4757 14.46 12.5811 17.0111 12.907L17.7119 12.992Z"
        fill={hoverd ? hoverColor : color}
      />
    </svg>
  );
};

export default TwitterIcon;

```

`zilpay.io/components/icons/view.tsx`:

```tsx
import React from "react";


type Prop = {
  color?: string;
  width?: number | string;
  height?: number | string;
};

export var ViewIcon: React.FC<Prop> = function ({
  color = 'var(--muted-color)',
  width = 16,
  height = 16,
}) {
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 24 24"
      fill="none"
      stroke={color}
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" />
      <polyline points="15 3 21 3 21 9" />
      <line x1="10" y1="14" x2="21" y2="3" />
    </svg>
  );
};

```

`zilpay.io/components/info-card/index.tsx`:

```tsx

import styles from "./index.module.scss";

import Image from "next/image";
import React from 'react';


type Prop = {
  url: string;
  title: string;
  selected?: boolean;
  children?: React.ReactNode;
};

export const InfoCard: React.FC<Prop> = ({ url, title, selected, children }) => (
  <div
    className={styles.card}
    style={{
      borderColor: selected ? 'var(--secondary-color)' : undefined
    }}
  >
    <Image
      src={url}
      alt="Icon"
      height={50}
      width={50}
    />
    <h3>
      {title}
    </h3>
    <b>
      {children}
    </b>
  </div>
);

```

`zilpay.io/components/modal/index.tsx`:

```tsx
import styles from "./index.module.scss";

import React from "react";
import classNames from "classnames";

import { CloseIcon } from "components/icons/close";


type Prop = {
  title?: React.ReactNode;
  show: boolean;
  width?: string;
  children?: React.ReactNode;
  onClose: () => void;
};

type HeadProp = {
  children?: React.ReactNode;
  onClose: () => void;
};

export var Modal: React.FC<Prop> = function ({
  children,
  title,
  show,
  width,
  onClose,
}) {
  const node = React.useRef<HTMLDivElement | null>(null);

  const onToggle = React.useCallback(
    (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {
      if (e.target == node.current) {
        onClose();
      }
    },
    [node, onClose],
  );

  return (
    <div
      className={classNames(styles.container, {
        'show-dialog': show
      })}
      ref={(n) => (node.current = n)}
      onClick={onToggle}
    >
      <div
        className={styles.modalmd}
        style={{
          width,
        }}
      >
        {title}
        <div>{children}</div>
      </div>
    </div>
  );
};

export const ModalHeader: React.FC<HeadProp> = ({
  children,
  onClose
}) => (
  <div className={styles.modalheader}>
    <h3>{children}</h3>
    <span onClick={onClose}>
      <CloseIcon />
    </span>
  </div>
);

```

`zilpay.io/components/modals/account/index.tsx`:

```tsx
import styles from "./index.module.scss";

import React from "react";
import { useStore } from "react-stores";
import { useTranslation } from "next-i18next";

import { Modal, ModalHeader } from "components/modal";
import { TxCard } from "components/tx-card";
import { $transactions, resetTransactions } from "store/transactions";
import { AccountCard } from "@/components/account-card";

import type { Wallet } from "@/types/wallet";
import { $wallet } from "@/store/wallet";
import { Toggle } from "@/components/toggle";
import { $settings, updateSettingsStore } from "@/store/settings";
import { Themes } from "@/config/themes";

type Prop = {
  show: boolean;
  address: Wallet | null;
  onClose: () => void;
};


export var AccountModal: React.FC<Prop> = function ({
  show,
  onClose,
  address
}) {
  const common = useTranslation(`common`);
  const { transactions } = useStore($transactions);
  const wallet = useStore($wallet);
  const settings = useStore($settings);

  const hanldeChangeTheme = React.useCallback((value: boolean) => {
    if (value) {
      updateSettingsStore({
        ...settings,
        theme: Themes.Dark
      });
    } else {
      updateSettingsStore({
        ...settings,
        theme: Themes.Light
      });
    }
  }, [settings]);

  return (
    <Modal
      show={show}
      title={(
        <ModalHeader onClose={onClose}>
          {common.t(`account`)}
        </ModalHeader>
      )}
      width="450px"
      onClose={onClose}
    >
      <AccountCard wallet={address} />
      <div className={styles.txlist}>
        <Toggle
          value={settings.theme === Themes.Dark}
          onToggle={hanldeChangeTheme}
        />
        {transactions.length === 0 ? (
          <p className={styles.here}>
            {common.t(`tx_appear_here`)}
          </p>
        ) : (
          <div>
            <div className={styles.header}>
              <p>
                {common.t(`recent_txns`)}
              </p>
              <p
                className={styles.clear}
                onClick={() => resetTransactions(String(wallet?.bech32))}
              >
                (
                {common.t(`clear_all`)}
                )
              </p>
            </div>
            {transactions.map((tx) => (
              <TxCard key={tx.hash} tx={tx} />
            ))}
          </div>
        )}
      </div>
    </Modal>
  );
};

```

`zilpay.io/components/modals/add-pool-preview/index.tsx`:

```tsx
import styles from './index.module.scss';

import React from "react";
import { useTranslation } from "next-i18next";
import Image from 'next/image';
import { useStore } from 'react-stores';
import Big from 'big.js';
import { ThreeDots } from 'react-loader-spinner';

import { ImagePair } from '@/components/pair-img';
import { Modal, ModalHeader } from "components/modal";

import { $tokens } from '@/store/tokens';
import { getIconURL } from '@/lib/viewblock';
import classNames from 'classnames';
import { DragonDex } from '@/mixins/dex';
import { TokensMixine } from '@/mixins/token';
import { $wallet } from '@/store/wallet';


type Prop = {
  show: boolean;
  amount: Big;
  limit: Big;
  tokenIndex: number;
  hasPool: boolean;
  onClose: () => void;
};

const dex = new DragonDex();
const tokensMixin = new TokensMixine();
export var AddPoolPreviewModal: React.FC<Prop> = function ({
  show,
  amount,
  limit,
  tokenIndex,
  hasPool,
  onClose
}) {
  const common = useTranslation(`common`);
  const tokensStore = useStore($tokens);
  const wallet = useStore($wallet);

  const [loading, setLoading] = React.useState(false);
  const [isAllow, setIsAllow] = React.useState(false);
  const [rewards, setRewards] = React.useState(0);

  const token0 = React.useMemo(() => {
    return tokensStore.tokens[0].meta;
  }, [tokensStore]);
  const token1 = React.useMemo(() => {
    return tokensStore.tokens[tokenIndex].meta;
  }, [tokensStore, tokenIndex]);

  const price = React.useMemo(() => {
    return dex.tokensToZil(Big(1), token1);
  }, [token1]);

  const hanldeaddLiquidity = React.useCallback(async() => {
    setLoading(true);

    try {
      const zilpay = await tokensMixin.zilpay.zilpay();

      if (!wallet || !zilpay.wallet.isEnable) {
        await zilpay.wallet.connect();
      }

      if (!isAllow) {
        const owner = String(wallet?.base16).toLowerCase();
        const balance = tokensStore.tokens[tokenIndex].balance[owner];
        await tokensMixin.increaseAllowance(
          dex.contract,
          token1.base16,
          balance
        );
        setLoading(false);
        setIsAllow(true);
        return;
      }

      const zilDecimals = dex.toDecimails(token0.decimals);
      const tokenDecimails = dex.toDecimails(token1.decimals);
      const qaAmount = amount.mul(tokenDecimails).round();
      const qaLimit = limit.mul(zilDecimals).round();

      await dex.addLiquidity(token1.base16, qaAmount, qaLimit, hasPool);
      onClose();
    } catch (err) {
      console.log(err);
      /////
    }
    setLoading(false);
  }, [token0, token1, amount, limit, onClose, isAllow, tokensStore, tokenIndex, wallet, hasPool]);

  const hanldeUpdate = React.useCallback(async() => {
    setLoading(true);
    try {
      const allowances = await tokensMixin.getAllowances(
        dex.contract,
        token1.base16
      );
      const tokenDecimails = dex.toDecimails(token1.decimals);
      const qaAmount = amount.mul(tokenDecimails).round();
      setIsAllow(
        tokensMixin.isAllow(String(qaAmount), String(allowances))
      );
    } catch {
      /////
    }
    setLoading(false);
  }, [token1, amount]);

  React.useEffect(() => {
    if (show) {
      hanldeUpdate();
    }
  }, [show]);

  React.useEffect(() => {
    if (show) {
      setRewards(dex.liquidityRewards);
    }
  }, [show, tokensStore]);

  return (
    <Modal
      show={show}
      title={(
        <ModalHeader onClose={onClose}>
          {common.t(`preview_modal.title`)}
        </ModalHeader>
      )}
      width="390px"
      onClose={onClose}
    >
      <div className={styles.container}>
        <div className={styles.head}>
          <ImagePair
            tokens={[
              token0,
              token1
            ]}
          />
          <span>
            <h3>
              {token0.symbol}
            </h3>
            <h3>
              /
            </h3>
            <h3>
              {token1.symbol}
            </h3>
          </span>
        </div>
        <div className={styles.info}>
          <div className={styles.infoitem}>
            <span>
              <Image
                src={getIconURL(token0.bech32)}
                alt={token0.symbol}
                key={token0.symbol}
                height="30"
                width="30"
              />
              <h3>
                {token0.symbol}
              </h3>
            </span>
            <h3>
              {limit.round(6).toString()}
            </h3>
          </div>
          <div className={styles.infoitem}>
            <span>
              <Image
                src={getIconURL(token1.bech32)}
                alt={token1.symbol}
                key={token1.symbol}
                height="30"
                width="30"
              />
              <h3>
                {token1.symbol}
              </h3>
            </span>
            <h3>
              {amount.round(6).toString()}
            </h3>
          </div>
          <div className={classNames(styles.infoitem, styles.fee)}>
            <p>
              {common.t('preview_modal.fee')}
            </p>
            <p>
              {rewards}%
            </p>
          </div>
        </div>
        {Number(price) > 0 ? (
          <div className={styles.price}>
            <p>
              {common.t('preview_modal.price')}
            </p>
            <h3>
              {price.toString()}
            </h3>
            <p>
              {token0.symbol} per {token1.symbol}
            </p>
          </div>
        ) : null}
        <button
          className={styles.submit}
          disabled={loading}
          onClick={hanldeaddLiquidity}
        >
          {loading ? (
            <ThreeDots
              color="var(--primary-color)"
              height={25}
              width={50}
            />
          ) : (
            <>
              {isAllow ? common.t('preview_modal.confirm_btn') : common.t('buttons.approve')}
            </>
          )}
        </button>
      </div>
    </Modal>
  );
};

```

`zilpay.io/components/modals/confirm-swap/index.tsx`:

```tsx
import styles from "./index.module.scss";

import type { SwapPair } from "@/types/swap";

import { ThreeDots } from "react-loader-spinner";
import _Big from "big.js";
import classNames from "classnames";
import { useStore } from "react-stores";
import toformat from 'toformat';
import React from "react";
import { useTranslation } from "next-i18next";

import { Modal, ModalHeader } from "components/modal";
import { FormInput } from "@/components/swap-form";

import { DragonDex, SwapDirection } from "@/mixins/dex";

import { $wallet } from "@/store/wallet";
import { TokensMixine } from "@/mixins/token";
import { $tokens } from "@/store/tokens";
import { DEFAULT_CURRENCY, ZERO_ADDR } from "@/config/conts";
import { $settings } from "@/store/settings";
import { DEFAUL_GAS } from "@/mixins/zilpay-base";
import { PriceInfo } from "@/components/price-info";
import { formatNumber } from "@/filters/n-format";
import { $liquidity } from "@/store/shares";


const Big = toformat(_Big);
Big.PE = 999;


type Prop = {
  show: boolean;
  pair: SwapPair[];
  direction: SwapDirection;
  gasLimit: _Big;
  onClose: () => void;
};


const tokensMixin = new TokensMixine();
const dex = new DragonDex();
export var ConfirmSwapModal: React.FC<Prop> = function ({
  show,
  pair,
  direction,
  gasLimit,
  onClose
}) {
  const common = useTranslation(`common`);
  const swap = useTranslation(`swap`);
  const wallet = useStore($wallet);
  const settings = useStore($settings);
  const liquidity = useStore($liquidity);

  const [loading, setLoading] = React.useState(true);
  const [isAllow, setIsAllow] = React.useState(false);
  const [priceRevert, setPriceRevert] = React.useState(true);

  const exact = React.useMemo(
    () => BigInt(Big(pair[0].value).mul(dex.toDecimails(pair[0].meta.decimals).round())),
    [pair]
  );
  const limit = React.useMemo(
    () => BigInt(Big(pair[1].value).mul(dex.toDecimails(pair[1].meta.decimals).round())),
    [pair]
  );

  const tokensPrices = React.useMemo(() => {
    if (priceRevert) {
      return [
        pair[0],
        pair[1],
      ];
    } else {
      return [
        pair[1],
        pair[0],
      ];
    }
  }, [priceRevert, pair]);

  const gasFee = React.useMemo(() => {
    if (!show) {
      return Big(0);
    }

    const gasPrice = Big(DEFAUL_GAS.gasPrice);
    const li = gasLimit.mul(gasPrice);

    return li.div(dex.toDecimails(6));
  }, [direction, show, gasLimit]);

  const expectedOutput = React.useMemo(() => {
    const [, limitToken] = pair;
    const limit = Big(limitToken.value);
    return limit.round(12).toFormat();
  }, [pair]);

  const priceImpact = React.useMemo(() => {
    const [exactToken, limitToken] = pair;
    const expectInput = Big(exactToken.value);
    const limitInput = Big(limitToken.value);
    let price = Big(0);
    let x = String(0);
    let y = String(0);
    let zilReserve = Big(0);
    let tokensReserve = Big(0);

    try {
      switch (direction) {
        case SwapDirection.ZilToToken:
          [x, y] = liquidity.pools[limitToken.meta.base16];
          zilReserve = Big(String(x)).div(dex.toDecimails(exactToken.meta.decimals));
          tokensReserve = Big(String(y)).div(dex.toDecimails(limitToken.meta.decimals));
          price = zilReserve.div(tokensReserve);
          return dex.calcPriceImpact(expectInput, limitInput, price);
        case SwapDirection.TokenToZil:
          [x, y] = liquidity.pools[exactToken.meta.base16];
          zilReserve = Big(String(x)).div(dex.toDecimails(limitToken.meta.decimals));
          tokensReserve = Big(String(y)).div(dex.toDecimails(exactToken.meta.decimals));
          price = tokensReserve.div(zilReserve);
          return dex.calcPriceImpact(expectInput, limitInput, price);
        case SwapDirection.TokenToTokens:
          const [zilliqa] = $tokens.state.tokens;
          const [inputZils, inputTokens] = liquidity.pools[exactToken.meta.base16];
          const [outpuZils, outputTokens] = liquidity.pools[limitToken.meta.base16];

          const bigInputZils = Big(String(inputZils)).div(dex.toDecimails(zilliqa.meta.decimals));
          const bigInputTokens = Big(String(inputTokens)).div(dex.toDecimails(exactToken.meta.decimals));
  
          const bigOutpuZils = Big(String(outpuZils)).div(dex.toDecimails(zilliqa.meta.decimals));
          const bigOutputTokens = Big(String(outputTokens)).div(dex.toDecimails(limitToken.meta.decimals));

          const inputRate = bigInputTokens.div(bigInputZils);
          const outpuRate = bigOutputTokens.div(bigOutpuZils);
          price = inputRate.div(outpuRate);

          return dex.calcPriceImpact(expectInput, limitInput, price);
        default:
          return 0;
      }
    } catch (err) {
      // console.error(err);
      return 0;
    }
  }, [direction, pair, liquidity]);

  const expectedOutputAfterSleepage = React.useMemo(() => {
    const [, limitToken] = pair;
    return Big(dex.sleepageCalc(String(limitToken.value))).round(12).toFormat();
  }, [pair]);

  const disabled = React.useMemo(() => {
    return loading || priceImpact > 30;
  }, [priceImpact, loading]);

  const approveToken = React.useCallback(async() => {
    const [exactToken] = pair;
    const owner = String(wallet?.base16).toLowerCase();
    const token = $tokens.state.tokens.find(
      (t) => t.meta.base16 === exactToken.meta.base16
    );
    const balance = token?.balance[owner] || '0';
    await tokensMixin.increaseAllowance(
      dex.contract,
      exactToken.meta.base16,
      balance
    );
  }, [wallet, pair]);

  const hanldeUpdate = React.useCallback(async() => {
    const [exactToken] = pair;
    if (exactToken.meta.base16 === ZERO_ADDR) {
      setIsAllow(true);
      setLoading(false);
      return;
    };

    setLoading(true);
    try {
      const allowances = await tokensMixin.getAllowances(
        dex.contract,
        exactToken.meta.base16
      );
      setIsAllow(
        tokensMixin.isAllow(String(exact), String(allowances))
      );
    } catch (err) {
      console.error('hanldeUpdate', err);
    }
    setLoading(false);
  }, [pair, exact]);

  const hanldeOnSwap = React.useCallback(async() => {
    setLoading(true);

    try {
      const zilpay = await tokensMixin.zilpay.zilpay();

      if (!wallet || !zilpay.wallet.isEnable) {
        await zilpay.wallet.connect();
      }

      switch (direction) {
        case SwapDirection.ZilToToken:
          await dex.swapExactZILForTokens(exact, limit, pair[1].meta);
          setLoading(false);
          onClose();
          return;
        case SwapDirection.TokenToZil:
          if (!isAllow) {
            await approveToken();
            setLoading(false);
            setIsAllow(true);
            return;
          }
          await dex.swapExactTokensForZIL(exact, limit, pair[0].meta);
          setLoading(false);
          onClose();
          return;
        case SwapDirection.TokenToTokens:
          if (!isAllow) {
            await approveToken();
            setLoading(false);
            setIsAllow(true);
            return;
          }
          await dex.swapExactTokensForTokens(
            exact,
            limit,
            pair[0].meta,
            pair[1].meta
          );
          setLoading(false);
          onClose();
          return;
      }
    } catch (err) {
      console.error(err);
    }

    setLoading(false);
  }, [
    pair,
    isAllow,
    exact,
    limit,
    direction,
    wallet,
    onClose,
    approveToken
  ]);

  React.useEffect(() => {
    hanldeUpdate();
  }, []);

  return (
    <Modal
      show={show}
      title={(
        <ModalHeader onClose={onClose}>
          {swap.t(`modals.confirm.title`)}
        </ModalHeader>
      )}
      width="450px"
      onClose={onClose}
    >
      <div className={styles.container}>
        <FormInput
          value={Big(pair[0].value)}
          token={pair[0].meta}
          disabled
        />
        <br />
        <FormInput
          value={Big(pair[1].value)}
          token={pair[1].meta}
          disabled
        />
        <PriceInfo
          tokens={tokensPrices}
          onClick={() => setPriceRevert(!priceRevert)}
        />
        <div className={styles.info}>
          <div className={styles.column}>
            <div className={styles.row}>
              <p>
                {swap.t(`modals.confirm.expected_output`)}
              </p>
              <p>
                {expectedOutput} {pair[1].meta.symbol}
              </p>
            </div>
            <div className={styles.row}>
              <p>
                {swap.t(`modals.confirm.price_impact`)}
              </p>
              <p>
                {String(priceImpact)}%
              </p>
            </div>
          </div>
          <div className={classNames(styles.column, 'muted')}>
            <div className={styles.row}>
              <p>
                {swap.t(`modals.confirm.min_slippage`)} ({settings.slippage}%)
              </p>
              <p>
                {expectedOutputAfterSleepage} {pair[1].meta.symbol}
              </p>
            </div>
            <div className={styles.row}>
              <p>
                {swap.t(`modals.confirm.fee`)}
              </p>
              <p>
                {String(gasFee)}ZIL ({formatNumber(Number(gasFee) * settings.rate, DEFAULT_CURRENCY)})
              </p>
            </div>
          </div>
        </div>
        <button
          className={classNames(styles.submit, {
            allow: isAllow
          })}
          onClick={hanldeOnSwap}
          disabled={disabled}
        >
          {loading ? (
            <ThreeDots
              color="var(--button-color)"
              height={25}
              width={50}
            />
          ) : (
            <>
              {isAllow ? swap.t(`modals.confirm.btn`) : common.t('buttons.approve')}
            </>
          )}
        </button>
      </div>
    </Modal>
  );
};

```

`zilpay.io/components/modals/settings/index.tsx`:

```tsx
import styles from './index.module.scss';

import React from "react";
import { useTranslation } from "next-i18next";

import { Modal, ModalHeader } from "components/modal";

import { BLOCKS, SLIPPAGE } from "@/config/conts";

import { $settings, updateSettingsStore } from "@/store/settings";
import { useStore } from "react-stores";

type Prop = {
  show: boolean;
  onClose: () => void;
};


export var SwapSettingsModal: React.FC<Prop> = function ({
  show,
  onClose
}) {
  const common = useTranslation(`common`);
  const settings = useStore($settings);

  const hanldeResetSlippage = React.useCallback(() => {
    updateSettingsStore({
      ...settings,
      slippage: SLIPPAGE
    });
  }, [settings]);
  const hanldeResetBlocks = React.useCallback(() => {
    updateSettingsStore({
      ...settings,
      blocks: BLOCKS
    });
  }, [settings]);
  const hanldeInputSlippage = React.useCallback((event: React.FormEvent<HTMLInputElement>) => {
    updateSettingsStore({
      ...settings,
      slippage: Number((event.target as HTMLInputElement).value)
    });
  }, [settings]);
  const hanldeInputBlocks = React.useCallback((event: React.FormEvent<HTMLInputElement>) => {
    updateSettingsStore({
      ...settings,
      blocks: Number((event.target as HTMLInputElement).value)
    });
  }, [settings]);

  return (
    <Modal
      show={show}
      title={(
        <ModalHeader onClose={onClose}>
          {common.t(`settings.title`)}
        </ModalHeader>
      )}
      width="390px"
      onClose={onClose}
    >
      <div className={styles.container}>
        <div className={styles.wrapper}>
          <p>
            {common.t('settings.slippage')}
          </p>
          <div className={styles.row}>
            <button onClick={hanldeResetSlippage}>
              Auto
            </button>
            <label>
              <input
                type="number"
                value={settings.slippage}
                onInput={(e) => hanldeInputSlippage(e)}
              />
              %
            </label>
          </div>
        </div>
        <br />
        <div className={styles.wrapper}>
          <p>
            {common.t('settings.deadline')}
          </p>
          <div className={styles.row}>
            <button onClick={hanldeResetBlocks}>
              Auto
            </button>
            <label>
              <input
                type="number"
                value={settings.blocks}
                onInput={hanldeInputBlocks}
              />
              {common.t('settings.blocks')}
            </label>
          </div>
        </div>
      </div>
    </Modal>
  );
};

```

`zilpay.io/components/modals/tokens/index.tsx`:

```tsx
import styles from './index.module.scss';

import type { Token, TokenState } from "@/types/token";

import { useStore } from "react-stores";
import React from "react";
import { useTranslation } from "next-i18next";
import Image from 'next/image';

import { Modal, ModalHeader } from "components/modal";

import { $wallet } from "@/store/wallet";
import { getIconURL } from '@/lib/viewblock';
import { formatNumber } from '@/filters/n-format';
import Big from 'big.js';
import { ZilPayBase } from '@/mixins/zilpay-base';
import { DragonDex } from '@/mixins/dex';
import { ThreeDots } from 'react-loader-spinner';
import { $tokens } from '@/store/tokens';

type Prop = {
  show: boolean;
  warn?: boolean;
  include?: boolean;
  exceptions?: string[];
  onClose: () => void;
  onSelect: (token: TokenState) => void;
};

Big.PE = 999;

const getAmount = (decimals: number, balance?: string) => {
  if (!balance) {
    return '';
  }

  const qa = Big(String(balance));
  const decimal = Big(10**decimals);
  const value = qa.div(decimal);

  return formatNumber(Number(value));
};

const zilpay = new ZilPayBase();
const dex = new DragonDex();
export var TokensModal: React.FC<Prop> = function ({
  show,
  onClose,
  onSelect,
  exceptions = [],
  warn = false,
  include = false
}) {
  const common = useTranslation(`common`);
  const wallet = useStore($wallet);
  const tokensStore = useStore($tokens);

  const inputRef = React.useRef<HTMLInputElement | null>(null);
  const lazyRoot = React.useRef(null);

  const [isImport, setImport] = React.useState(false);
  const [loading, setLoading] = React.useState(false);
  const [base16, setBase16] = React.useState('');
  const [search, setSearch] = React.useState('');

  const tokens = React.useMemo(() => {
    return tokensStore.tokens.filter(
      (t) => t.meta.symbol.toLowerCase().includes(search.toLowerCase())
    );
  }, [tokensStore, search]);

  const hanldeInput = React.useCallback(async(event: React.FormEvent<HTMLInputElement>) => {
    try {
      const zp = await zilpay.zilpay();
      const base16 = zp.crypto.fromBech32Address((event.target as HTMLInputElement).value);

      setBase16(base16);
    } catch {
      ///
    }
  }, []);

  const hanldeAddToken = React.useCallback(async() => {
    if (!wallet?.base16) return;

    setLoading(true);
    try {
      await dex.addCustomToken(base16, wallet.base16);
      setImport(false);
    } catch (err) {
      console.warn(err);
      ///
    }
    setLoading(false);
  }, [wallet, base16]);

  const hanldeOnSelect = React.useCallback((token: TokenState) => {
    if (exceptions.includes(token.base16)) {
      return;
    }

    onSelect(token);
  }, [exceptions]);

  const handleSubmit = React.useCallback((event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const [first] = tokens;

    if (first) {
      hanldeOnSelect(first.meta);
    }
  }, [tokens]);

  React.useEffect(() => {
    if (show && inputRef.current) {
      inputRef.current.focus();
    }
  }, [inputRef, show]);

  return (
    <Modal
      show={show}
      title={(
        <ModalHeader onClose={onClose}>
          {common.t(`tokens.title`)}
        </ModalHeader>
      )}
      width="400px"
      onClose={onClose}
    >
      {warn ? (
        <div className={styles.warnwrapper}>
          <p className={styles.warn}>
            {common.t('tokens.warn')}
          </p>
        </div>
      ) : null}
      {isImport ? (
        <div className={styles.import}>
          <div>
            <p>
              {common.t('tokens.import_warn')}
            </p>
          </div>
          <input
            type="text"
            placeholder={common.t('tokens.placeholder')}
            onInput={hanldeInput}
          />
          <div className={styles.buttons}>
            <button
              disabled={!Boolean(base16)}
              onClick={hanldeAddToken}
            >
              {loading ? (
                <ThreeDots
                  height="30"
                  width="30"
                  color="var(--primary-color)"
                />
              ) : common.t('tokens.buttons.add')}
            </button>
            <button onClick={() => setImport(false)}>
              {common.t('tokens.buttons.cancel')}
            </button>
          </div>
        </div>
      ) : (
        <form
          className={styles.listwarp}
          onSubmit={handleSubmit}
        >
          <input
            className={styles.search}
            placeholder={'Symbol'}
            ref={inputRef}
            onInput={(event) => setSearch(event.currentTarget.value)}
          />
          <ul
            className={styles.container}
            ref={lazyRoot}
          >
            {tokens.map((token) => (
              <li
                key={token.meta.base16}
                className={styles.tokencard}
                onClick={() => hanldeOnSelect(token.meta)}
              >
                <Image
                  src={getIconURL(token.meta.bech32)}
                  alt={token.meta.symbol}
                  lazyRoot={lazyRoot}
                  height="50"
                  width="50"
                />
                <div className={styles.tokenwrapper}>
                  <p className={styles.left}>
                    {token.meta.symbol}
                  </p>
                  <p className={styles.right}>
                    {token.meta.name}
                  </p>
                </div>
                <p>
                  {String(getAmount(token.meta.decimals, token.balance[String(wallet?.base16).toLowerCase()]))}
                </p>
              </li>
            ))}
          </ul>
        </form>
      )}
      <div className={styles.include}>
        {include && !isImport ? (
          <p onClick={() => setImport(true)}>
            {common.t('tokens.buttons.import')}
          </p>
        ) : null}
      </div>
    </Modal>
  );
};

```

`zilpay.io/components/nav-bar/index.tsx`:

```tsx
import styles from "./index.module.scss";

import React from 'react';
import { useStore } from "react-stores";
import Link from 'next/link';
import Image from "next/image";

import { ConnectZIlPay } from "@/components/zilpay-connect";
import { Toggle } from "@/components/toggle";
import { $settings, updateSettingsStore } from "@/store/settings";
import { Themes } from "@/config/themes";


export const NavBar: React.FC = () => {
  const settings = useStore($settings);

  const hanldeChangeTheme = React.useCallback((value: boolean) => {
    if (value) {
      updateSettingsStore({
        ...settings,
        theme: Themes.Dark
      });
    } else {
      updateSettingsStore({
        ...settings,
        theme: Themes.Light
      });
    }
  }, [settings]);

  return (
    <nav className={styles.navbar}>
      <Link href="/" passHref>
        <div className={styles.logo}>
          <Image
            src="/icons/zilpay.svg"
            alt="Logo"
            height={30}
            width={30}
          />
          <h3>
            ZilPay
          </h3>
        </div>
      </Link>
      <div className={styles.center}>
        <Link href="/swap" passHref>
          <h3>
            SWAP
          </h3>
        </Link>
        <Link href="/pool" passHref>
          <h3>
            POOL
          </h3>
        </Link>
      </div>
      <div className={styles.buttons}>
        <ConnectZIlPay />
        <Toggle
          value={settings.theme === Themes.Dark}
          onToggle={hanldeChangeTheme}
        />
      </div>
    </nav>
  );
};

```

`zilpay.io/components/pair-img/index.tsx`:

```tsx
import styles from './index.module.scss';

import type { TokenState } from '@/types/token';

import Image from 'next/image';
import React from "react";
import { getIconURL } from '@/lib/viewblock';

type Prop = {
  tokens: TokenState[];
};

export const ImagePair: React.FC<Prop> = ({ tokens }) => {
  return (
    <div className={styles.imgwrap}>
      {tokens.map((el) => (
        <Image
          src={getIconURL(el.bech32)}
          alt={el.symbol}
          key={el.symbol}
          height="30"
          width="30"
          className={styles.symbol}
        />
      ))}
    </div>
  );
};
```

`zilpay.io/components/pool/add-pool/index.tsx`:

```tsx
import styles from './index.module.scss';

import { useStore } from 'react-stores';
import React from 'react';
import Big from 'big.js';
import { useTranslation } from 'next-i18next';
import classNames from 'classnames';
import Link from 'next/link';

import { FormInput, SwapSettings } from '@/components/swap-form';
import { TokensModal } from '@/components/modals/tokens';
import { BackIcon } from '@/components/icons/back';

import { $tokens } from '@/store/tokens';
import { $wallet } from '@/store/wallet';

import { DragonDex } from '@/mixins/dex';

import { ZERO_ADDR } from '@/config/conts';
import { AddPoolPreviewModal } from '@/components/modals/add-pool-preview';
import { SwapSettingsModal } from '@/components/modals/settings';
import { $liquidity } from '@/store/shares';
import { TokenState } from '@/types/token';


type Prop = {
  index: number;
};

const dex = new DragonDex();
export const AddPoolForm: React.FC<Prop> = ({ index }) => {
  const pool = useTranslation(`pool`);

  const tokensStore = useStore($tokens);
  const wallet = useStore($wallet);
  const liquidity = useStore($liquidity);

  const [amount, setAmount] = React.useState(Big(0));
  const [limitAmount, setLimitAmount] = React.useState(Big(0));

  const [token, setToken] = React.useState(index);
  const [tokensModal, setTokensModal] = React.useState(false);
  const [previewModal, setPreviewModal] = React.useState(false);
  const [settingsModal, setSettingsModal] = React.useState(false);

  const tokenBalance = React.useMemo(() => {
    let balance = '0';
    const owner = String(wallet?.base16).toLowerCase();

    if (tokensStore.tokens[token] && tokensStore.tokens[token].balance[owner]) {
      balance = tokensStore.tokens[token].balance[owner];
    }

    return Big(balance);
  }, [wallet, tokensStore, token]);

  const exceptions = React.useMemo(() => {
    return [ZERO_ADDR, tokensStore.tokens[token].meta.base16];
  }, [tokensStore, token]);

  const hasPool = React.useMemo(() => {
    return Boolean(liquidity.pools[tokensStore.tokens[token].meta.base16]);
  }, [liquidity, tokensStore, token]);

  const disabled = React.useMemo(() => {
    const decimals = dex.toDecimails(tokensStore.tokens[token].meta.decimals);
    const qa = amount.mul(decimals);
    let isLess = false;

    if (!hasPool) {
      const zilDecimals = dex.toDecimails(tokensStore.tokens[0].meta.decimals);
      isLess = BigInt(String(limitAmount.mul(zilDecimals).round())) < dex.lp;
    }

    return Number(amount) === 0 || tokenBalance.lt(qa) || isLess;
  }, [tokenBalance, amount, limitAmount, tokensStore, token, hasPool]);

  const hanldeSelectToken0 = React.useCallback((t: TokenState) => {
    const foundIndex = tokensStore
    .tokens
    .findIndex((p) => p.meta.base16 === t.base16);

    if (foundIndex >= 0 && t.base16 !== ZERO_ADDR) {
      setToken(foundIndex);
      setTokensModal(false);
    }
  }, [tokensStore]);

  const handleSubmit = React.useCallback((event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setPreviewModal(true);
  }, []);

  React.useEffect(() => {
    const tokenMeta = tokensStore.tokens[token].meta;
    const pool = liquidity.pools[tokenMeta.base16];

    if (pool && pool.length >= 2) {
      setLimitAmount(
        dex.calcVirtualAmount(amount, tokenMeta, pool)
      );
    }
  }, [amount, token, liquidity, tokensStore]);

  return (
    <>
      <SwapSettingsModal
        show={settingsModal}
        onClose={() => setSettingsModal(false)}
      />
      <TokensModal
        show={tokensModal}
        exceptions={exceptions}
        warn
        include
        onClose={() => setTokensModal(false)}
        onSelect={hanldeSelectToken0}
      />
      <AddPoolPreviewModal
        show={previewModal}
        amount={amount}
        limit={limitAmount}
        tokenIndex={token}
        hasPool={hasPool}
        onClose={() => setPreviewModal(false)}
      />
      <form
        className={styles.container}
        onSubmit={handleSubmit}
      >
        <div className={styles.row}>
          <Link href="/pool" passHref>
            <div className={styles.hoverd}>
              <BackIcon />
            </div>
          </Link>
          <h3>
            {pool.t('add_pool.title')}
          </h3>
          <SwapSettings onClick={() => setSettingsModal(true)}/>
        </div>
        <div className={classNames(styles.row, {
          border: true
        })}>
          <div className={styles.column}>
            <p>
              {pool.t('add_pool.sub_title')}
            </p>
            <FormInput
              value={amount}
              token={tokensStore.tokens[token].meta}
              balance={tokensStore.tokens[token].balance[String(wallet?.base16).toLowerCase()]}
              onSelect={() => setTokensModal(true)}
              onInput={setAmount}
              onMax={setAmount}
            />
            <FormInput
              value={limitAmount}
              token={tokensStore.tokens[0].meta}
              balance={tokensStore.tokens[0].balance[String(wallet?.base16).toLowerCase()]}
              disabled={hasPool}
              onInput={setLimitAmount}
              onMax={setLimitAmount}
            />
          </div>
        </div>
        <button disabled={disabled}>
          {pool.t('add_pool.button')}
        </button>
      </form>
    </>
  );
};

```

`zilpay.io/components/pool/index.ts`:

```ts
export * from './add-pool';
export * from './pools-overview';
export * from './remove-pool';

```

`zilpay.io/components/pool/pools-overview/index.tsx`:

```tsx
import styles from './index.module.scss';

import React from 'react';
import { useStore } from 'react-stores';
import classNames from 'classnames';
import Big from 'big.js';
import Link from 'next/link';
import { Puff } from 'react-loader-spinner';
import { useTranslation } from 'next-i18next';

import { ImagePair } from '@/components/pair-img';

import { $wallet } from '@/store/wallet';
import { $liquidity } from '@/store/shares';
import { $tokens } from '@/store/tokens';

import { nPool } from '@/filters/n-pool';
import { formatNumber } from '@/filters/n-format';

import { DEFAULT_CURRENCY, SHARE_PERCENT_DECIMALS } from '@/config/conts';
import { DragonDex } from '@/mixins/dex';
import { $settings } from '@/store/settings';

type Prop = {
  loading: boolean;
};

const dex = new DragonDex();
export const PoolOverview: React.FC<Prop> = ({ loading }) => {
  const pool = useTranslation(`pool`);

  const wallet = useStore($wallet);
  const liquidity = useStore($liquidity);
  const tokensStore = useStore($tokens);
  const settings = useStore($settings);

  const list = React.useMemo(() => {
    if (!wallet || tokensStore.tokens.length === 0) {
      return [];
    }
    const tokens = [];
    const zilToken = tokensStore.tokens[0].meta;
    const { pools, shares } = liquidity;
    const rate = Big(settings.rate);

    for (const token in shares) {
      try {
        const share = Big(String(shares[token])).div(Big(SHARE_PERCENT_DECIMALS)).round(2);
        const foundIndex = tokensStore.tokens.findIndex((t) => t.meta.base16 === token);
        const pool = pools[token];
        const limitToken = tokensStore.tokens[foundIndex];
        const [x, y] = nPool(pool, shares[token]);
        const zilReserve = Big(x.toString()).div(dex.toDecimails(zilToken.decimals));
        const tokenReserve = Big(y.toString()).div(dex.toDecimails(limitToken.meta.decimals));
        const zilsTokens = dex.tokensToZil(tokenReserve, limitToken.meta);
        const zils = zilReserve.add(zilsTokens);

        tokens.push({
          share: share.lt(0.001) ? '0.01<' : String(share),
          token: limitToken.meta,
          zilReserve: formatNumber(String(zilReserve)),
          tokenReserve: formatNumber(String(tokenReserve)),
          price: formatNumber(String(zils.mul(rate)), DEFAULT_CURRENCY)
        });
      } catch {
        continue;
      }
    }

    return tokens;
  }, [wallet, liquidity, tokensStore, settings]);

  return (
    <div className={styles.container}>
      <div className={styles.row}>
        <h3>
          {pool.t('overview.title')}
        </h3>
        <Link href="/pool/add" passHref>
          <button>
            {pool.t('overview.button')}
          </button>
        </Link>
      </div>
      {list.length === 0 ? (
        <div className={styles.wrapper}>
          {loading ? (
            <Puff color="var(--primary-color)"/>
          ) : (
            <>
              <svg
                width="48"
                height="48"
                viewBox="0 0 24 24"
                fill="none"
                stroke="var(--muted-color)"
                strokeWidth="1"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="22 12 16 12 14 15 10 15 8 12 2 12" />
                <path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"/>
              </svg>
              <p>
                {pool.t('overview.info')}
              </p>
            </>
          )}
        </div>
      ) : (
        <div className={classNames(styles.wrapper, styles.cardwrapper)}>
          {list.map((el) => (
            <Link
              href={`/pool/${el.token.base16}`}
              key={el.token.base16}
              passHref
            >
              <div className={styles.poolcard}>
                <div className={styles.cardrow}>
                  <ImagePair
                    tokens={[
                      tokensStore.tokens[0].meta,
                      el.token
                    ]}
                  />
                  <p>
                    ZIL / {el.token.symbol} - <span>
                      {el.share}%
                    </span>
                  </p>
                </div>
                <div className={styles.cardrow}>
                  <p className={styles.amount}>
                    {el.zilReserve} / {el.tokenReserve} ≈ {el.price}
                  </p>
                </div>
              </div>
            </Link>
          ))}
        </div>
      )}
    </div>
  );
};

```

`zilpay.io/components/pool/remove-pool/index.tsx`:

```tsx
import 'rc-slider/assets/index.css';
import styles from './index.module.scss';

import type { Token } from '@/types/token';

import React from 'react';
import { useStore } from 'react-stores';
import Link from 'next/link';
import { useTranslation } from 'next-i18next';
import Big from 'big.js';

import { $wallet } from '@/store/wallet';
import { $liquidity } from '@/store/shares';
import { $tokens } from '@/store/tokens';
import { DragonDex } from '@/mixins/dex';

import { ImagePair } from '@/components/pair-img';
import { BackIcon } from '@/components/icons/back';
import Slider from 'rc-slider';

import { nPool } from '@/filters/n-pool';
import { ThreeDots } from 'react-loader-spinner';
import { formatNumber } from '@/filters/n-format';
import { TokensMixine } from '@/mixins/token';

Big.PE = 999;

type Prop = {
  token: Token;
};

const tokensMixin = new TokensMixine();
const dex = new DragonDex();
export const RemovePoolForm: React.FC<Prop> = ({ token }) => {
  const pool = useTranslation(`pool`);

  const wallet = useStore($wallet);
  const liquidity = useStore($liquidity);
  const tokensStore = useStore($tokens);

  const [loading, setLoading] = React.useState(false);

  const [zilReserve, setZilReserve] = React.useState(Big(0));
  const [tokenReserve, setTokenReserve] = React.useState(Big(0));

  const [zil, setZil] = React.useState(Big(0));
  const [zrc, setZrc] = React.useState(Big(0));
  const [range, setRange] = React.useState(1);
  const [userContributions, setUserContributions] = React.useState(Big(0));

  const tokenAddress = React.useMemo(() => {
    return String(token.meta.base16).toLowerCase();
  }, [token]);
  const owner = React.useMemo(() => {
    return String(wallet?.base16).toLowerCase();
  }, [wallet]);

  const hanldeOnRemove = React.useCallback(async() => {
    setLoading(true);
    try {
      const zilpay = await tokensMixin.zilpay.zilpay();

      if (!wallet || !zilpay.wallet.isEnable) {
        await zilpay.wallet.connect();
      }

      const zilToken = tokensStore.tokens[0].meta;
      const minZIL = zil.mul(dex.toDecimails(zilToken.decimals));
      const minZrc = zrc.mul(dex.toDecimails(token.meta.decimals));
      const res = await dex.removeLiquidity(
        minZIL,
        minZrc,
        userContributions,
        tokenAddress,
        owner
      );

      console.log(res);
    } catch (err) {
      console.error(err);
    }
    setLoading(false);
  }, [zil, zrc, tokenAddress, userContributions, owner, token, tokensStore, wallet]);

  const hanldeRange = React.useCallback((range: number | number[]) => {
    const _100 = BigInt(100);
    const percent = BigInt(Number(range));
    const zil = tokensStore.tokens[0].meta;
    const userContributions = BigInt(liquidity.balances[owner] && liquidity.balances[owner][tokenAddress] || 0);
    const newZil = (BigInt(String(zilReserve)) * percent) / _100;
    const newTokens = (BigInt(String(tokenReserve)) * percent) / _100;
    const newUserContributions = (userContributions * percent) / _100;

    setZil(Big(String(newZil)).div(dex.toDecimails(zil.decimals)));
    setZrc(Big(String(newTokens)).div(dex.toDecimails(token.meta.decimals)));
    setRange(Number(range));
    setUserContributions(Big(String(newUserContributions)));
  }, [zilReserve, tokenReserve, tokensStore, owner, token, liquidity, tokenAddress]);

  React.useEffect(() => {
    try {
      const pool = liquidity.pools[String(token.meta.base16).toLowerCase()];
      const [x, y] = nPool(pool, liquidity.shares[tokenAddress]);

      const zilReserve = Big(x.toString());
      const tokenReserve = Big(y.toString());
  
      setZilReserve(zilReserve);
      setTokenReserve(tokenReserve);
      setUserContributions(Big(liquidity.balances[owner][tokenAddress] || 0));
    } catch (err) {
      // console.error(err);
    }
    // @ts-ignore
  }, [wallet, liquidity, tokenAddress, tokensStore, token, owner]);

  return (
    <div className={styles.container}>
      <div className={styles.row}>
        <Link href="/pool" passHref>
          <div className={styles.hoverd}>
            <BackIcon />
          </div>
        </Link>
        <h3>
          {pool.t('remove_pool.title')}
        </h3>
        <ImagePair
          tokens={[
            tokensStore.tokens[0].meta,
            token.meta
          ]}
        />
      </div>
      <div className={styles.wrapper}>
        <Slider
          min={1}
          max={100}
          railStyle={{
            backgroundColor: 'var(--button-color)',
            height: '6px'
          }}
          trackStyle={{
            backgroundColor: 'var(--primary-color)',
            height: '6px'
          }}
          handleStyle={{
            height: '17px',
            width: '17px',
            borderColor: 'var(--primary-color)',
            backgroundColor: 'var(--card-color)',
            opacity: '1'
          }}
          step={1}
          onChange={hanldeRange}
        />
        <p>
          {range}%
        </p>
        <div className={styles.cards}>
          <div className={styles.card}>
            {formatNumber(Number(zil))} <span>
              {tokensStore.tokens[0].meta.symbol}
            </span>
          </div>
          <svg
            focusable="false"
            viewBox="0 0 24 24"
            aria-hidden="true"
            height="30"
            width="30"
          >
            <path
              d="M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"
              fill='var(--primary-color)'
            />
          </svg>
          <div className={styles.card}>
            {formatNumber(Number(zrc))} <span>
              {token.meta.symbol}
            </span>
          </div>
        </div>
      </div>
      <button
        disabled={loading}
        onClick={hanldeOnRemove}
      >
        {loading ? (
          <ThreeDots
              color="var(--primary-color)"
              height={25}
              width={50}
            />
          ) : pool.t('remove_pool.button')}
      </button>
    </div>
  );
};

```

`zilpay.io/components/price-info/index.tsx`:

```tsx
import styles from "./index.module.scss";

import type { SwapPair } from "@/types/swap";

import _Big from "big.js";
import { useStore } from "react-stores";
import React from "react";
import toformat from 'toformat';

import { DragonDex } from "@/mixins/dex";
import { DEFAULT_CURRENCY, ZERO_ADDR } from "@/config/conts";
import { $tokens } from "@/store/tokens";
import { $settings } from "@/store/settings";
import { formatNumber } from "@/filters/n-format";
import { $liquidity } from "@/store/shares";
import ArrowIcon from "../icons/arrow";

const Big = toformat(_Big);

Big.PE = 999;


type Prop = {
  tokens: SwapPair[];
  onClick?: () => void;
  onShow?: () => void;
};

const dex = new DragonDex();
export var PriceInfo: React.FC<Prop> = function ({
  tokens,
  onShow,
  onClick = () => null
}) {
  const tokensStore = useStore($tokens);
  const settingsStore = useStore($settings);
  const liquidity = useStore($liquidity);

  const price = React.useMemo(() => {
    const [x, y] = tokens;
    const one = Big(1);
    let price = Big(0);

    if (Number(x.value) > 0 && Number(y.value) > 0) {
      return Big(y.value).div(x.value);
    }

    try {
      if (x.meta.base16 === ZERO_ADDR && y.meta.base16 !== ZERO_ADDR) {
        const [bigZil, bigTokens] = liquidity.pools[y.meta.base16];
        const zilReserve = Big(String(bigZil)).div(dex.toDecimails(x.meta.decimals));
        const tokensReserve = Big(String(bigTokens)).div(dex.toDecimails(y.meta.decimals));

        price = tokensReserve.div(zilReserve);
      } else if (y.meta.base16 === ZERO_ADDR && x.meta.base16 !== ZERO_ADDR) {
        const [bigZil, bigTokens] = liquidity.pools[x.meta.base16];
        const zilReserve = Big(String(bigZil)).div(dex.toDecimails(y.meta.decimals));
        const tokensReserve = Big(String(bigTokens)).div(dex.toDecimails(x.meta.decimals));

        price = zilReserve.div(tokensReserve);
      } else {
        const [zilliqa] = tokensStore.tokens;
        const [inputZils, inputTokens] = liquidity.pools[x.meta.base16];
        const [outpuZils, outputTokens] = liquidity.pools[y.meta.base16];

        const bigInputZils = Big(String(inputZils)).div(dex.toDecimails(zilliqa.meta.decimals));
        const bigInputTokens = Big(String(inputTokens)).div(dex.toDecimails(x.meta.decimals));

        const bigOutpuZils = Big(String(outpuZils)).div(dex.toDecimails(zilliqa.meta.decimals));
        const bigOutputTokens = Big(String(outputTokens)).div(dex.toDecimails(y.meta.decimals));

        const inputRate = bigInputTokens.div(bigInputZils);
        const outpuRate = bigOutputTokens.div(bigOutpuZils);
        const value = one.mul(outpuRate).div(inputRate);

        price = value.div(one);
      }
    } catch {
      ///
    }

    return price;
  }, [tokens, tokensStore, liquidity]);

  const converted = React.useMemo(() => {
    const [x] = tokens;
    const { rate } = settingsStore;

    if (x.meta.base16 === ZERO_ADDR) {
      return formatNumber(rate, DEFAULT_CURRENCY);
    }

    return formatNumber(Number(price) * rate, DEFAULT_CURRENCY);
  }, [tokens, settingsStore, price]);

  return (
    <div className={styles.container}>
      <p onClick={onClick}>
        1 {tokens[0].meta.symbol} = {price.round(12).toFormat()} {tokens[1].meta.symbol} <span>
          ({converted})
        </span>
      </p>
      {onShow ? (
        <span onClick={onShow}>
          <ArrowIcon color="var(--secondary-color)" />
        </span>
      ) : null}
    </div>
  );
};

```

`zilpay.io/components/smart-button/index.tsx`:

```tsx
import styles from './index.module.scss';

import { useTranslation } from 'next-i18next';
import React from 'react';

import SafariIcon from 'components/icons/safari';
import ChromeIcon from 'components/icons/chrome';
import FireFoxIcon from 'components/icons/firefox';

type Prop = {
  userAgent?: string;
};

const iconSize = 50;
export const SmartButton: React.FC<Prop> = ({ userAgent }) => {
  const main = useTranslation(`main`);

  const isFirefox = React.useMemo(() => Boolean(String(userAgent).match(
    /Firefox/i
  )), [userAgent]);
  const isSafari = React.useMemo(() => Boolean(String(userAgent).match(
    /Safari/i
  )), [userAgent]);
  const isChrome = React.useMemo(() => Boolean(String(userAgent).match(
    /Chrome/i
  )), [userAgent]);

  if (isChrome) {
    return (
      <a
        className={styles.button}
        href="https://chrome.google.com/webstore/detail/zilpay/klnaejjgbibmhlephnhpmaofohgkpgkd"
        target="_blank"
        rel="noreferrer"
      >
        <ChromeIcon
          height={iconSize}
          width={iconSize}
          color="var(--primary-color)"
        />
        <b>
          {main.t('main.button.chrome')}
        </b>
      </a>
    );
  }

  if (isSafari) {
    return (
      <a
        className={styles.button}
        href="https://apps.apple.com/ru/app/zilpay-extension/id1598114655?l=en&mt=12"
        target="_blank"
        rel="noreferrer"
      >
        <SafariIcon
          height={iconSize}
          width={iconSize}
          color="var(--primary-color)"
        />
        <b>
          {main.t('main.button.safari')}
        </b>
      </a>
    );
  }

  if (isFirefox) {
    return (
      <a
        className={styles.button}
        href="https://addons.mozilla.org/en-GB/firefox/addon/zilpay/"
        target="_blank"
        rel="noreferrer"
      >
        <FireFoxIcon
          height={iconSize}
          width={iconSize}
          color="var(--primary-color)"
        />
        <b>
          {main.t('main.button.firefox')}
        </b>
      </a>
    );
  }

  return (
    <div className={styles.row}>
      <FireFoxIcon
        height={iconSize}
        width={iconSize}
        color="var(--primary-color)"
      />
      <ChromeIcon
        height={iconSize}
        width={iconSize}
        color="var(--primary-color)"
      />
      <SafariIcon
        height={iconSize}
        width={iconSize}
        color="var(--primary-color)"
      />
    </div>
  );
};

```

`zilpay.io/components/swap-form/form.tsx`:

```tsx
import styles from './index.module.scss';

import type { SwapPair } from '@/types/swap';
import type { TokenState } from '@/types/token';

import Big from 'big.js';
import React from 'react';
import { useTranslation } from 'next-i18next';
import { useStore } from 'react-stores';

import { SwapSettings } from './settings';
import { FormInput } from './input';
import SwapIcon from 'components/icons/swap';
import { ConfirmSwapModal } from '@/components/modals/confirm-swap';
import { TokensModal } from '@/components/modals/tokens';
import { SwapSettingsModal } from '@/components/modals/settings';
import { PriceInfo } from '@/components/price-info';

import { DragonDex } from '@/mixins/dex';

import { $tokens } from '@/store/tokens';
import { $wallet } from '@/store/wallet';
import { $liquidity } from '@/store/shares';
import { $net } from '@/store/netwrok';
import classNames from 'classnames';
import { ZERO_ADDR } from '@/config/conts';
import { viewAddress } from '@/lib/viewblock';


type Prop = {
  startPair: SwapPair[];
};


Big.PE = 999;
const dex = new DragonDex();

export const SwapForm: React.FC<Prop> = ({ startPair }) => {
  const { t } = useTranslation(`swap`);

  const tokensStore = useStore($tokens);
  const wallet = useStore($wallet);
  const liquidity = useStore($liquidity);
  const network = useStore($net);

  const [modal0, setModal0] = React.useState(false);
  const [modal1, setModal1] = React.useState(false);
  const [modal3, setModal3] = React.useState(false);
  const [confirmModal, setConfirmModal] = React.useState(false);
  const [info, setInfo] = React.useState(false);

  const [priceFrom, setPriceFrom] = React.useState(true);
  const [pair, setPair] = React.useState<SwapPair[]>(startPair);

  const tokensForPrice = React.useMemo(() => {
    if (priceFrom) {
      return [
        pair[0],
        pair[1],
      ];
    } else {
      return [
        pair[1],
        pair[0],
      ];
    }
  }, [priceFrom, pair]);

  const balances = React.useMemo(() => {
    let balance0 = '0';
    let balance1 = '0';

    if (!wallet) {
      return [balance0, balance1];
    }

    const found0 = tokensStore.tokens.find((t) => t.meta.base16 === pair[0].meta.base16);
    const found1 = tokensStore.tokens.find((t) => t.meta.base16 === pair[1].meta.base16);

    if (found0 && found0.balance[String(wallet.base16).toLowerCase()]) {
      balance0 = found0.balance[String(wallet.base16).toLowerCase()];
    }

    if (found1 && found1.balance[String(wallet.base16).toLowerCase()]) {
      balance1 = found1.balance[String(wallet.base16).toLowerCase()];
    }

    return [balance0, balance1];
  }, [pair, tokensStore, wallet]);

  const disabled = React.useMemo(() => {
    const amount = Big(pair[0].value).mul(dex.toDecimails(pair[0].meta.decimals)).round();
    const isBalance = BigInt(String(amount)) > BigInt(balances[0]);
    return Number(pair[0].value) <= 0 || Number(pair[1].value) <= 0 || !(wallet?.base16) || isBalance;
  }, [pair, wallet, balances]);

  const direction = React.useMemo(() => {
    return dex.getDirection(pair);
  }, [pair]);

  const gasLimit = React.useMemo(() => {
    return dex.calcGasLimit(direction);
  }, [direction]);


  const hanldeOnSwapForms = React.useCallback(() => {
    setPair(JSON.parse(JSON.stringify(pair.reverse())));
  }, [pair]);

  const hanldeSubmit = React.useCallback((event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setConfirmModal(true);
  }, []);

  const hanldeOnInput = React.useCallback((value: string | Big) => {
    const unLinkedPair = JSON.parse(JSON.stringify(pair));

    unLinkedPair[0].value = String(value);
    unLinkedPair[1].value = dex.getRealPrice(unLinkedPair);

    console.log(unLinkedPair);

    setPair(unLinkedPair);
  }, [pair]);

  const hanldeOnSelectToken = React.useCallback((token: TokenState, index: number) => {
    const unLinkedPair = JSON.parse(JSON.stringify(pair));

    unLinkedPair[1].value = String(0);
    unLinkedPair[0].value = String(0);
    unLinkedPair[index].meta = token;

    setPair(unLinkedPair);
    setModal0(false);
    setModal1(false);
  }, [pair]);

  React.useEffect(() => {
    if (Number(pair[0].value) > 0) {
      hanldeOnInput(pair[0].value);
    }
  }, [liquidity, tokensStore]);

  return (
    <>
      <SwapSettingsModal
        show={modal3}
        onClose={() => setModal3(false)}
      />
      {confirmModal ? (
        <ConfirmSwapModal
          show={confirmModal}
          pair={pair}
          direction={direction}
          gasLimit={gasLimit}
          onClose={() => setConfirmModal(false)}
        />
      ) : null}
      <TokensModal
        show={modal0}
        warn
        include
        exceptions={pair.map((t) => t.meta.base16)}
        onClose={() => setModal0(false)}
        onSelect={(token) => hanldeOnSelectToken(token, 0)}
      />
      <TokensModal
        show={modal1}
        include
        warn
        exceptions={pair.map((t) => t.meta.base16)}
        onClose={() => setModal1(false)}
        onSelect={(token) => hanldeOnSelectToken(token, 1)}
      />
      {pair.length === 2 ? (
        <form
          className={styles.container}
          onSubmit={hanldeSubmit}
        >
          <div className={styles.wrapper}>
            <h3>
              {t('title')} {network.net !== 'mainnet' ? (
                <span>
                  ({network.net})
                </span>
              ) : null}
            </h3>
            <SwapSettings onClick={() => setModal3(true)}/>
          </div>
          <FormInput
            value={Big(pair[0].value)}
            token={pair[0].meta}
            balance={balances[0]}
            gasLimit={gasLimit}
            onSelect={() => setModal0(true)}
            onInput={hanldeOnInput}
            onMax={hanldeOnInput}
          />
          <SwapIcon onClick={hanldeOnSwapForms}/>
          <FormInput
            value={Big(pair[1].value)}
            token={pair[1].meta}
            balance={balances[1]}
            disabled
            onSelect={() => setModal1(true)}
          />
          <PriceInfo
            tokens={tokensForPrice}
            onClick={() => setPriceFrom(!priceFrom)}
            onShow={() => setInfo(!info)}
          />
          <ul className={classNames(styles.info, {
            show: info
          })}>
            <p>
              {t('info.warn')}
            </p>
            <li>
              {t('info.verify')} {pair.filter((t) => t.meta.base16 !== ZERO_ADDR).map((token) => (
                <a
                  key={token.meta.base16}
                  href={viewAddress(token.meta.bech32)}
                  target="_blank"
                  rel="noopener noreferrer"
                >
                  {token.meta.symbol} {' '}
                </a>
              ))}
            </li>
          </ul>
          <button>
            {t('buttons.exchange')}
          </button>
        </form>
      ) : null}
    </>
  );
}

```

`zilpay.io/components/swap-form/index.ts`:

```ts
export * from './form';
export * from './input';
export * from './settings/index';

```

`zilpay.io/components/swap-form/input/index.tsx`:

```tsx
import styles from './index.module.scss';

import type { TokenState } from "@/types/token";

import React from "react";
import Big from "big.js";
import Image from 'next/image';

import { getIconURL } from "@/lib/viewblock";
import classNames from 'classnames';
import { DEFAULT_CURRENCY, ZERO_ADDR } from '@/config/conts';
import { DragonDex } from '@/mixins/dex';
import { formatNumber } from '@/filters/n-format';
import { useStore } from 'react-stores';
import { $settings } from '@/store/settings';
import { $tokens } from '@/store/tokens';
import ArrowIcon from '@/components/icons/arrow';
import { DEFAUL_GAS } from '@/mixins/zilpay-base';


Big.PE = 999;


type Prop = {
  token: TokenState;
  value: Big;
  balance?: string;
  disabled?: boolean;
  gasLimit?: Big;
  onInput?: (value: Big) => void;
  onSelect?: () => void;
  onMax?: (b: Big) => void;
};

const list = [0, 10, 25, 50, 75, 100];
const dex = new DragonDex();
export const FormInput: React.FC<Prop> = ({
  value,
  token,
  balance = BigInt(0),
  disabled = false,
  gasLimit = Big(0),
  onInput = () => null,
  onSelect = () => null,
  onMax = () => null
}) => {
  const settings = useStore($settings);
  const tokensStore = useStore($tokens);

  const converted = React.useMemo(() => {
    const rate = Big(settings.rate);

    if (token.base16 === ZERO_ADDR) {
      return formatNumber(String(value.mul(rate)), DEFAULT_CURRENCY);
    }

    const zils = dex.tokensToZil(value, token);
    return formatNumber(String(zils.mul(rate)), DEFAULT_CURRENCY);
  }, [settings, value, tokensStore, token]);

  const hanldePercent = React.useCallback((n: number) => {
    const percent = BigInt(n);
    let value = (BigInt(balance) * percent / BigInt(100));

    if (token.base16 === ZERO_ADDR) {
      const gasPrice = Big(DEFAUL_GAS.gasPrice);
      const li = gasLimit.mul(gasPrice);
      const fee = BigInt(li.mul(dex.toDecimails(6)).round().toString());

      if (fee > value) {
        value = BigInt(0);
      } else {
        value -= fee;
      }
    }

    const decimals = dex.toDecimails(token.decimals);

    onMax(Big(String(value)).div(decimals));
  }, [balance, token, onMax, gasLimit]);

  const hanldeOnInput = React.useCallback((event: React.FormEvent<HTMLInputElement>) => {
    const target = event.target as HTMLInputElement;

    try {
      if (target.value) {
        onInput(Big(target.value));
      } else {
        onInput(Big(0));
      }
    } catch {
      ////
    }
  }, [onInput]);

  return (
    <label>
      <div
        className={classNames(styles.container)}
      >
        <div className={styles.wrapper}>
          <input
            value={String(value)}
            disabled={disabled}
            onInput={hanldeOnInput}
          />
          <div
            className={classNames(styles.dropdown)}
            onClick={onSelect}
          >
            <Image
              src={getIconURL(token.bech32)}
              alt="tokens-logo"
              height="30"
              width="30"
            />
            <p>
              {token.symbol}
            </p>
            <ArrowIcon color="var(--primary-color)"/>
          </div>
        </div>
        <div className={styles.wrapper}>
          <p>
            {converted}
          </p>
          {disabled ? null : (
            <div className={styles.row}>
              {list.map((n) => (
                <p
                  key={n}
                  className={styles.balance}
                  onClick={() => hanldePercent(n)}
                >
                  {n}%
                </p>
              ))}
            </div>
          )}
        </div>
      </div>
    </label>
  );
};

```

`zilpay.io/components/swap-form/settings/index.tsx`:

```tsx
import styles from './index.module.scss';

import React from 'react';

type Prop = {
  onClick: () => void;
}


export const SwapSettings: React.FC<Prop> = ({ onClick }) => {
  return (
    <>
      <div
        className={styles.container}
        onClick={() => onClick()}
      >
        <svg width="22" height="27" viewBox="0 0 26 27" fill="none">
          <path
            d="M15.4267 26.8333H10.5734C9.94687 26.8333 9.40479 26.3973 9.27071 25.7853L8.72805 23.2733C8.00412 22.9561 7.31768 22.5595 6.68138 22.0906L4.23205 22.8706C3.63472 23.0611 2.98536 22.8097 2.67205 22.2666L0.240049 18.0653C-0.0698339 17.522 0.036927 16.8366 0.497382 16.4133L2.39738 14.68C2.31098 13.8948 2.31098 13.1025 2.39738 12.3173L0.497382 10.588C0.0362488 10.1644 -0.0705545 9.47825 0.240049 8.93463L2.66672 4.73063C2.98003 4.18756 3.62938 3.93614 4.22672 4.12663L6.67605 4.90663C7.00147 4.6655 7.34023 4.44292 7.69072 4.23996C8.02717 4.05022 8.37343 3.87842 8.72805 3.72529L9.27205 1.21596C9.40547 0.603918 9.94697 0.167285 10.5734 0.166626H15.4267C16.0531 0.167285 16.5946 0.603918 16.728 1.21596L17.2774 3.72663C17.6518 3.89131 18.0164 4.0774 18.3694 4.28396C18.6986 4.47438 19.0169 4.68315 19.3227 4.90929L21.7734 4.12929C22.3703 3.93952 23.0189 4.19084 23.332 4.73329L25.7587 8.93729C26.0686 9.48061 25.9618 10.166 25.5014 10.5893L23.6014 12.3226C23.6878 13.1078 23.6878 13.9001 23.6014 14.6853L25.5014 16.4186C25.9618 16.8419 26.0686 17.5273 25.7587 18.0706L23.332 22.2746C23.0189 22.8171 22.3703 23.0684 21.7734 22.8786L19.3227 22.0986C19.0126 22.327 18.6904 22.5384 18.3574 22.732C18.0078 22.9345 17.6473 23.1175 17.2774 23.28L16.728 25.7853C16.5941 26.3968 16.0527 26.8328 15.4267 26.8333ZM7.16005 19.1386L8.25338 19.9386C8.49985 20.1202 8.75673 20.2871 9.02272 20.4386C9.27298 20.5836 9.53067 20.7153 9.79471 20.8333L11.0387 21.3786L11.648 24.1666H14.3547L14.964 21.3773L16.208 20.832C16.7511 20.5925 17.2666 20.2947 17.7454 19.944L18.84 19.144L21.5614 20.0106L22.9147 17.6666L20.804 15.7426L20.9534 14.3933C21.019 13.8031 21.019 13.2075 20.9534 12.6173L20.804 11.268L22.916 9.33996L21.5614 6.99463L18.84 7.86129L17.7454 7.06129C17.2664 6.70891 16.751 6.40897 16.208 6.16663L14.964 5.62129L14.3547 2.83329H11.648L11.036 5.62263L9.79471 6.16663C9.53046 6.28268 9.27274 6.4131 9.02272 6.55729C8.75836 6.7084 8.50284 6.87444 8.25738 7.05463L7.16272 7.85463L4.44272 6.98796L3.08672 9.33996L5.19738 11.2613L5.04805 12.612C4.98245 13.2021 4.98245 13.7978 5.04805 14.388L5.19738 15.7373L3.08672 17.6613L4.44005 20.0053L7.16005 19.1386ZM12.9947 18.8333C10.0492 18.8333 7.66138 16.4455 7.66138 13.5C7.66138 10.5544 10.0492 8.16663 12.9947 8.16663C15.9402 8.16663 18.328 10.5544 18.328 13.5C18.3244 16.444 15.9387 18.8296 12.9947 18.8333ZM12.9947 10.8333C11.5379 10.8348 10.3519 12.0051 10.331 13.4617C10.3101 14.9184 11.4621 16.1222 12.9183 16.1655C14.3745 16.2087 15.5958 15.0753 15.6614 13.62V14.1533V13.5C15.6614 12.0272 14.4675 10.8333 12.9947 10.8333Z"
            fill="var(--text-color)"
          />
        </svg>
      </div>
    </>
  );
};

```

`zilpay.io/components/toggle/index.tsx`:

```tsx
import styles from "./index.module.scss";

import React from "react";
import classNames from "classnames";

type Prop = {
  value: boolean;
  onToggle: (value: boolean) => void;
};

export const Toggle: React.FC<Prop> = ({
  value,
  onToggle
}) => {
  return (
    <label className={styles.toggle}>
      <input
        type="checkbox"
        name="darkMode"
        onInput={() => onToggle(!value)}
      />
      <span className={classNames(styles.iconwrapper, {
        selected: value
      })}>
        <span className={classNames(styles.toogledot, {
          selected: value
        })}/>
        {!value ? (
          <svg
            width="12"
            height="12"
            viewBox="0 0 12 12"
            fill="none"
          >
            <path
              d="M5.993 0a.428.428 0 0 0-.421.434v1.284a.428.428 0 1 0 .856 0V.434A.428.428 0 0 0 5.993 0zM2.06 1.632a.428.428 0 0 0-.298.735l.908.909a.428.428 0 1 0 .606-.606l-.908-.908a.428.428 0 0 0-.308-.13zm7.867 0a.428.428 0 0 0-.295.13l-.908.908a.428.428 0 1 0 .606.606l.908-.909a.429.429 0 0 0-.311-.735zM6 3.002a2.997 2.997 0 1 0 0 5.995 2.997 2.997 0 0 0 0-5.994zM.434 5.573a.428.428 0 1 0 0 .856H1.72a.428.428 0 1 0 0-.856H.434zm9.847 0a.428.428 0 1 0 0 .856h1.285a.428.428 0 1 0 0-.856H10.28zM2.965 8.595a.428.428 0 0 0-.295.13l-.908.907a.428.428 0 1 0 .606.606l.908-.908a.428.428 0 0 0-.311-.735zm6.058 0a.428.428 0 0 0-.299.735l.908.908a.428.428 0 1 0 .606-.606l-.908-.908a.428.428 0 0 0-.307-.13zm-3.03 1.252a.428.428 0 0 0-.421.434v1.285a.428.428 0 1 0 .856 0V10.28a.429.429 0 0 0-.435-.434z"
              fill="var(--button-color)"
            />
          </svg>
        ) : (
          <svg
            width="12"
            height="12"
            viewBox="0 0 12 12"
            fill="none"
          >
            <path
              d="M8.049 4.291l-1.043.22.714.792-.113 1.06.974-.435.973.435-.113-1.06.714-.792-1.043-.22-.531-.924-.532.924zM11.209 8.59l-.684-.145-.348-.605-.348.605-.683.144.468.519-.074.694.637-.285.638.285-.074-.694.468-.519z" fill="#fff"></path><path d="M5.354 6A6 6 0 0 1 8.677.63a6 6 0 1 0 0 10.741A6 6 0 0 1 5.354 6z"
              fill="var(--button-color)"
            />
          </svg>
        )}
      </span>
    </label>
  );
};

```

`zilpay.io/components/tx-card/index.tsx`:

```tsx
import styles from "./index.module.scss";

import type { Tx } from 'types/zilliqa';

import { Puff } from "react-loader-spinner";
import React from "react";
import { viewTransaction } from "lib/viewblock";

import { SuccessIcon } from "components/icons/success";
import { RejectIcon } from "components/icons/reject";
import { useStore } from "react-stores";
import { $net } from "@/store/netwrok";

type Prop = {
  tx: Tx;
};

type StatusIconProp = {
  rejected?: boolean;
  loading: boolean;
};


const StatusIcon: React.FC<StatusIconProp> = function ({ rejected, loading }) {
  if (rejected && !loading) {
    return <RejectIcon />;
  }

  if (!rejected && !loading) {
    return <SuccessIcon />;
  }

  return <Puff
    color="var(--text-color)"
    height={16}
    width={16}
  />;
};

export var TxCard: React.FC<Prop> = function ({ tx }) {
  const net = useStore($net);
  return (
    <a
      className={styles.txcard}
      href={viewTransaction(tx.hash, net.net)}
      target="_blank" rel="noreferrer"
    >
      <div className={styles.wrapper}>
        <p>
          {tx.name}
          {` `}
          ↗
        </p>
      </div>
      <StatusIcon
        rejected={tx.error}
        loading={!tx.confirmed}
      />
    </a>
  );
};

```

`zilpay.io/components/zilpay-connect/index.tsx`:

```tsx
import styles from './index.module.scss';

import type { Wallet } from '@/types/wallet';

import React from "react";
import { useStore } from 'react-stores';

import { AccountModal } from '@/components/modals/account/index';
import { ThreeDots } from 'react-loader-spinner';

import { $wallet } from '@/store/wallet';
import { $transactions, updateTransactions } from '@/store/transactions';
import { $net } from '@/store/netwrok';

import { Blockchain } from '@/mixins/custom-fetch';
import { ZilPayBase } from '@/mixins/zilpay-base';
import { trim } from '@/lib/trim';
import { DragonDex } from '@/mixins/dex';

const chainFetcher = new Blockchain();
const zilPayWallet = new ZilPayBase();
const dex = new DragonDex();

let observer: any = null;
let observerNet: any = null;
let observerBlock: any = null;
export const ConnectZIlPay: React.FC = function () {
  const wallet = useStore($wallet);
  const transactionsStore = useStore($transactions);

  const [accountModal, setAccountModal] = React.useState(false);
  const [loading, setLoading] = React.useState(true);

  const isLoading = React.useMemo(() => {
    const { transactions } = transactionsStore;

    if (transactions.length === 0) {
      return true;
    }
    
    return transactions.filter((tx) => !tx.confirmed).length === 0;
  }, [transactionsStore]);

  const transactionsCheck = async() => {
    let { transactions } = $transactions.state;

    const params = transactions
      .filter((tx) => !tx.confirmed)
      .map((tx) => tx.hash);

    if (params.length === 0) {
      return null;
    }

    const resList = await chainFetcher.getTransaction(...params);

    for (let index = 0; index < transactions.length; index++) {
      try {
        const tx = transactions[index];
        const found = resList.find((res) => res.result.ID === tx.hash);

        if (!found) {
          continue;
        }

        transactions[index].confirmed = true;
        transactions[index].error = !found.result.receipt.success;
      } catch {
        //
      }
    }

    updateTransactions(String($wallet.state?.bech32), transactions);
  };

  const hanldeObserverState = React.useCallback(
    (zp: any) => {
      $net.setState({
        net: zp.wallet.net
      });

      if (observerNet) {
        observerNet.unsubscribe();
      }
      if (observer) {
        observer.unsubscribe();
      }
      if (observerBlock) {
        observerBlock.unsubscribe();
      }

      observerNet = zp.wallet.observableNetwork().subscribe((net: string) => {
        $net.setState({
          net
        });
        dex.updateTokens();
      });

      observer = zp.wallet.observableAccount().subscribe((acc: Wallet) => {
        const address = $wallet.state;

        if (address?.base16 !== acc.base16) {
          $wallet.setState(acc);
        }

        $transactions.resetState();

        const cache = window.localStorage.getItem(
          String(acc.bech32)
        );

        if (cache) {
          $transactions.setState(JSON.parse(cache));
        }

        dex.updateTokens();
      });

      observerBlock = zp.wallet
        .observableBlock()
        .subscribe(() => {
          transactionsCheck();
          dex.updateTokens();
          dex.updateState();
        });

      if (zp.wallet.defaultAccount) {
        $wallet.setState(zp.wallet.defaultAccount);
      }

      const cache = window.localStorage.getItem(
        String(zp.wallet.defaultAccount?.bech32),
      );

      if (cache) {
        $transactions.setState(JSON.parse(cache));
      }

      transactionsCheck();
    },
    [],
  );

  const handleConnect = async() => {
    setLoading(true);

    try {
      const zp = await zilPayWallet.zilpay();
      const connected = await zp.wallet.connect();

      if (connected && zp.wallet.defaultAccount) {
        $wallet.setState(zp.wallet.defaultAccount);
      }

      $net.setState({
        net: zp.wallet.net
      });

      const cache = window.localStorage.getItem(
        String(zp.wallet.defaultAccount?.base16),
      );

      if (cache) {
        $transactions.setState(JSON.parse(cache));
      }
    } catch (err) {
      console.warn(err);
    }

    setLoading(false);
  };

  React.useEffect(() => {
    zilPayWallet
      .zilpay()
      .then((zp) => {
        hanldeObserverState(zp);
        setLoading(false);
      })
      .catch((err) => {
        setLoading(false);
      });

    return () => {
      if (observer) {
        observer.unsubscribe();
      }
      if (observerNet) {
        observerNet.unsubscribe();
      }
      if (observerBlock) {
        observerBlock.unsubscribe();
      }
    };
  }, [hanldeObserverState]);

  return (
    <>
      <AccountModal
        show={accountModal}
        address={wallet}
        onClose={() => setAccountModal(false)}
      />
      {wallet ? (
        <button
          className={styles.connect}
          onClick={() => setAccountModal(true)}
        >
          {isLoading ? (
            trim(wallet.bech32)
          ) : (
            <>
              <b>
                Pending 
              </b>
              <ThreeDots
                color="var(--text-color)"
                height={10}
                width={15}
              />
            </>
          )}
        </button>
      ) : (
        <button
        className={styles.connect}
          onClick={handleConnect}
        >
          {loading ? (
            <ThreeDots
              color="var(--text-color)"
              height={10}
              width={20}
            />
          ) : (
            `Connect`
          )}
        </button>
      )}
    </>
  );
};

```

`zilpay.io/config/conts.ts`:

```ts
export const ZERO_ADDR = '0x0000000000000000000000000000000000000000';
export const ZERO_BECH32 = 'zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz';
export const LIMIT = 10;
export const NET = 'mainnet';
export const SLIPPAGE = 3;
export const BLOCKS = 10;
export const DEFAULT_TOKEN_INDEX = 1;
export const SHARE_PERCENT = BigInt('10000000000000000');
export const SHARE_PERCENT_DECIMALS = '100000000000000';
export const DEFAULT_CURRENCY = 'USD';

```

`zilpay.io/config/links.ts`:

```ts
export enum AppLinks {
  APK = 'https://github.com/zilpay/zilpay-mobile/releases/latest/download/app-release.apk',
  IOS = 'https://apps.apple.com/ru/app/zilpay/id1547105860',
  GOOGLE = 'https://play.google.com/store/apps/details?id=com.zilpaymobile',
  RUSTORE = 'https://www.rustore.ru/catalog/app/com.zilpaymobile',
  APPGALLERY = 'https://appgallery.huawei.com/app/C113872161',
  FIREFOX = 'https://addons.mozilla.org/en-GB/firefox/addon/zilpay/',
  CHROME = 'https://chrome.google.com/webstore/detail/zilpay/klnaejjgbibmhlephnhpmaofohgkpgkd',
  SAFARI = 'https://apps.apple.com/ru/app/zilpay-extension/id1598114655?l=en&mt=12'
}

```

`zilpay.io/config/storage-fields.ts`:

```ts
export enum StorageFields {
  Liquidity = 'liquidity',
  Tokens = 'tokens',
  Settings = 'settings'
}

```

`zilpay.io/config/themes.ts`:

```ts
export enum Themes {
  Dark = 'dark',
  Light = 'light'
}

```

`zilpay.io/filters/n-format.ts`:

```ts
export function formatNumber(balance: number | string, currency?: string) {
  const locale = 'en';// navigator.language;
  let opt: Intl.NumberFormatOptions = {
    style: undefined,
    currency: undefined,
    maximumSignificantDigits: 5,
    notation: "compact"
  };

  if (currency) {
    opt.style = 'currency';
    opt.currency = currency;
  }

  try {
    return new Intl
      .NumberFormat(locale, opt)
      .format(Number(balance));
  } catch {
    opt.style = undefined;
    opt.currency = undefined;

    const n = new Intl
      .NumberFormat(locale, opt)
      .format(Number(balance));
    return `${currency} ${n}`;
  }
}

```

`zilpay.io/filters/n-pool.ts`:

```ts
import { SHARE_PERCENT } from "@/config/conts";


export function nPool(pool: string[], share: bigint) {
  const [x, y] = pool;

  return [
    (BigInt(x) * BigInt(share)) / SHARE_PERCENT,
    (BigInt(y) * BigInt(share)) / SHARE_PERCENT
  ];
}

```

`zilpay.io/lib/chunk.ts`:

```ts
export function chunk<T>(arr: T[], size: number): Array<T[]> {
  if (size <= 0) {
    throw new Error('Incorrect size');
  }

  const R = [];
  for (var i=0,len=arr.length; i<len; i+=size)
    R.push(arr.slice(i,i+size));
  return R;
}

```

`zilpay.io/lib/compact.ts`:

```ts
export function compact<T>(array: Array<T[]>): T[] {
  let tmp: T[] = [];

  for (let index = 0; index < array.length; index++) {
    const element = array[index];
    tmp = [...tmp, ...element];
  }

  return tmp;
}

```

`zilpay.io/lib/parse-init.ts`:

```ts
import { ParamItem } from "@/types/token";

export enum InitFields {
  ContractOwner = 'contract_owner',
  Name = 'name',
  Symbol = 'symbol',
  Decimals = 'decimals',
  Address = '_this_address',
  InitSupply = 'init_supply'
}

export function findParam(init: ParamItem[], vname: string): undefined | string {
  return init.find((param) => param.vname === vname)?.value as string;
}

export function initParser(init: ParamItem[]) {
  const symbol = findParam(init, InitFields.Symbol) || '';
  const name = findParam(init, InitFields.Name) || '';
  const decimals = Number(findParam(init, InitFields.Decimals));
  const initSupply = findParam(init, InitFields.InitSupply);
  const contractOwner = findParam(init, InitFields.ContractOwner) || findParam(init, 'contract_owner');
  const address = findParam(init, InitFields.Address) || '';

  return {
    name,
    symbol,
    decimals,
    initSupply,
    contractOwner,
    address
  };
}

```

`zilpay.io/lib/to-hex.ts`:

```ts
export function toHex(addr: string) {
  return String(addr).toLowerCase().replace('0x', '');
}

```

`zilpay.io/lib/trim.ts`:

```ts
export function trim(str: string, length = 6) {
  if (!str) {
    return null;
  }

  const part0 = str.substr(0, length);
  const part1 = str.substr(length * -1);

  return `${part0}...${part1}`;
}

```

`zilpay.io/lib/viewblock.ts`:

```ts
import { NET } from "@/config/conts";
import { $settings } from '@/store/settings';

enum Methods {
  Address = `address`,
  Tx = `tx`,
}

const url = `https://viewblock.io/zilliqa`;

export function viewAddress(address: string) {
  return `${url}/${Methods.Address}/${address}?network=${NET}`;
}

export function viewTransaction(hash: string, net = NET) {
  return `${url}/${Methods.Tx}/${hash}?network=${net}`;
}

export function getIconURL(addr: string) {
  const { theme } = $settings.state;
  addr = (addr === 'zil1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq9yf6pz') ? 'ZIL' : addr;

  return `https://meta.viewblock.io/zilliqa.${addr}/logo?t=${theme}`;
}

```

`zilpay.io/mixins/backend.ts`:

```ts
import type { ListedTokenResponse } from "@/types/token";

export enum BackendMethods {
  Tokens = `tokens`,
  Rate = 'rates',
  Dex = 'dex'
}

export class ZilPayBackend {
  private _host = 'https://api.zilpay.io';
  // private _host = 'http://127.0.0.1:3000';
  // private _host = typeof window !== 'undefined' ?
  //   'https://api.zilpay.io' : `http://127.0.0.1:4000`;
  private _api = `api/v1`;

  public async getListedTokens(): Promise<ListedTokenResponse> {
    try {
      const url = new URL(
        `${this._host}/${this._api}/${BackendMethods.Dex}`,
      );
      const res = await fetch(url.toString());

      if (res.status !== 200) {
        return {
          tokens: {
            list: [],
            count: 0
          },
          rate: 0,
          pools: {}
        };
      }

      const result = await res.json();

      return result;
    } catch (err) {
      console.error('getListedTokens', err);
      return {
        tokens: {
          list: [],
          count: 0
        },
        rate: 0,
        pools: {}
      };
    }
  }
}

```

`zilpay.io/mixins/custom-fetch.ts`:

```ts
import type { FieldTotalContributions, FiledBalances, FiledPools, RPCResponse } from "@/types/zilliqa";

import { compact } from "@/lib/compact";
import { toHex } from "@/lib/to-hex";
import { chunk } from "@/lib/chunk";
import { initParser } from "@/lib/parse-init";
import { Token } from "@/types/token";
import { ZilPayBase } from "./zilpay-base";
import { ZERO_ADDR } from "@/config/conts";

import { $net } from '@/store/netwrok';

type Params = string[] | number[] | (string | string[] | number[])[];

export enum RPCMethods {
  GetSmartContractSubState = 'GetSmartContractSubState',
  GetTransaction = 'GetTransaction',
  GetSmartContractInit = 'GetSmartContractInit',
  GetBalance = 'GetBalance',
  GetLatestTxBlock = 'GetLatestTxBlock'
}

export enum DexFields {
  Pools = 'pools',
  LiquidityFee = 'liquidity_fee',
  ProtocolFee = 'protocol_fee',
  RewardsPool = 'rewards_pool',
  MinLP = 'min_lp',
  Balances = 'balances',
  TotalContributions = 'total_contributions'
}

export enum ZRC2Fields {
  Balances = 'balances'
}

export class Blockchain {
  private _http = {
    "mainnet": "https://api.zilliqa.com",
    "testnet": "https://dev-api.zilliqa.com"
  };
  readonly #rpc = {
    id: 1,
    jsonrpc: '2.0'
  };

  public get http() {
    const net = $net.state.net as 'mainnet' | 'testnet';
    return this._http[net];
  }

  public async getTransaction(...hash: string[]) {
    const batch = hash.map((hash) => ({
      method: RPCMethods.GetTransaction,
      params: [hash],
      id: 1,
      jsonrpc: `2.0`,
    }));
    return this._send(batch);
  }

  public async getUserBlockTotalContributions(dex: string, token: string, owner: string) {
    token = token.toLowerCase();
    owner = owner.toLowerCase();
    dex = toHex(dex);
    const batch = [
      this._buildBody(
        RPCMethods.GetSmartContractSubState,
        [dex, DexFields.Balances, [token, owner]]
      ),
      this._buildBody(
        RPCMethods.GetLatestTxBlock,
        []
      ),
      this._buildBody(
        RPCMethods.GetSmartContractSubState,
        [dex, DexFields.Pools, [token]]
      )
    ];
    const [resUserContributions, resBlock, resPool] = await this._send(batch);
    const userContributions = resUserContributions.result && resUserContributions.result[DexFields.Balances] ?
      resUserContributions.result[DexFields.Balances][token][owner] : '0';
    const blockNum = resBlock.result.header.BlockNum;
    const pool = resPool.result[DexFields.Pools][token].arguments;

    return {
      userContributions,
      blockNum,
      pool
    };
  }

  public async getBlockTotalContributions(dex: string, token: string) {
    token = token.toLowerCase();
    dex = toHex(dex);
    const batch = [
      this._buildBody(
        RPCMethods.GetSmartContractSubState,
        [dex, DexFields.TotalContributions, [token]]
      ),
      this._buildBody(
        RPCMethods.GetLatestTxBlock,
        []
      ),
      this._buildBody(
        RPCMethods.GetSmartContractSubState,
        [dex, DexFields.Pools, [token]]
      )
    ];
    const [resTotalContributions, resBlock, resPool] = await this._send(batch);
    const totalContributions = resTotalContributions.result ?
      resTotalContributions.result[DexFields.TotalContributions][token] : '0';
    const blockNum = resBlock.result.header.BlockNum;
    const pool = resPool.result ?
      resPool.result[DexFields.Pools][token].arguments : ['0', '0'];

    return {
      totalContributions,
      blockNum,
      pool
    };
  }

  public async fetchFullState(dex: string, owner: string) {
    const batch = [
      this._buildBody(
        RPCMethods.GetSmartContractSubState,
        [dex, 'balances', []] 
      ),
      this._buildBody(
        RPCMethods.GetSmartContractSubState,
        [dex, 'total_contributions', []] 
      ),
      this._buildBody(
        RPCMethods.GetSmartContractSubState,
        [dex, 'pools', []] 
      ),
    ];

    const [resBalances, resTotalContributions, resPools, ] = await this._send(batch);

    const balances: FiledBalances = resBalances.result ? resBalances.result.balances : {};
    const totalContributions: FieldTotalContributions = resTotalContributions.result ?
      resTotalContributions.result.total_contributions : {};
    const pools: FiledPools = resPools.result ? resPools.result.pools : {};

    return {
      balances,
      totalContributions,
      pools,
    };
  }

  public async getToken(token: string, owner: string) {
    owner = owner.toLowerCase();

    const batch = [
      this._buildBody(
        RPCMethods.GetSmartContractInit,
        [toHex(token)]
      ),
      this._buildBody(
        RPCMethods.GetSmartContractSubState,
        [toHex(token), ZRC2Fields.Balances, [owner]]
      )
    ];
    const [resInit, resBalances] = await this._send(batch);
    const meta = initParser(resInit.result);
    const balances = resBalances.result ?
      resBalances.result[ZRC2Fields.Balances] : {};


    return {
      meta,
      balances
    };
  }

  public async fetchTokensBalances(owner: string, tokens: Token[]) {
    owner = owner.toLowerCase();

    const reqList = tokens.slice(1).map((token) => this._buildBody(
      RPCMethods.GetSmartContractSubState,
      [toHex(token.meta.base16), ZRC2Fields.Balances, [owner.toLowerCase()]]
    ));
    const batch = [
      this._buildBody(
        RPCMethods.GetBalance,
        [toHex(owner)]
      ),
      ...reqList
    ];
    const batchRes = await this._send(batch);
    
    for (let index = 0; index < tokens.length; index++) {
      const token = tokens[index];

      if (token.meta.base16 === ZERO_ADDR) {
        tokens[index].balance[owner] = batchRes[index].result ?
          batchRes[index].result.balance : '0';
        continue;
      }

      tokens[index].balance[owner] = batchRes[index].result ?
        batchRes[index].result[ZRC2Fields.Balances][owner] : '0';
    }

    return tokens;
  }

  public async fetchTokens(owner: string, tokens: string[], pools: Token[]) {
    const reqList = tokens.map((token) => ([
      this._buildBody(
        RPCMethods.GetSmartContractInit,
        [toHex(token)]
      ),
      this._buildBody(
        RPCMethods.GetSmartContractSubState,
        [toHex(token), ZRC2Fields.Balances, [owner.toLowerCase()]]
      )
    ]));
    const tokensBatch = compact(reqList);
    const batch = [
      {
        method: RPCMethods.GetBalance,
        params: [
          toHex(owner)
        ],
        id: 1,
        jsonrpc: `2.0`,
      },
      ...tokensBatch
    ];
    const batchRes = await this._send(batch);
    const tokensRes = batchRes.slice(1);
    const chunks = chunk<RPCResponse>(tokensRes, 2);
    const zp = await new ZilPayBase().zilpay();

    for (const iterator of chunks) {
      const [init, balancesRes] = iterator;
      const meta = initParser(init.result);
      const balances = balancesRes.result ? balancesRes.result[ZRC2Fields.Balances] : {};
      const foundIndex = pools.findIndex((t) => t.meta.base16 === meta.address);

      if (foundIndex >= 0) {
        pools[foundIndex].meta = {
          decimals: meta.decimals,
          scope: 0,
          bech32: zp.crypto.toBech32Address(meta.address),
          base16: meta.address,
          name: meta.name,
          symbol: meta.symbol
        };
        pools[foundIndex].balance = {
          ...pools[foundIndex].balance,
          ...balances
        };
      } else {
        pools.push({
          meta: {
            decimals: meta.decimals,
            bech32: zp.crypto.toBech32Address(meta.address),
            base16: meta.address,
            scope: 0,
            name: meta.name,
            symbol: meta.symbol
          },
          balance: balances
        });
      }
    }

    if (batchRes[0].result) {
      pools[0].balance = {
        ...pools[0].balance,
        [owner.toLowerCase()]: batchRes[0].result.balance
      };
    } else {
      pools[0].balance = {
        ...pools[0].balance,
        [owner.toLowerCase()]: '0'
      };
    }

    return pools;
  }


  private _buildBody(method: string, params: Params) {
    return {
      ...this.#rpc,
      method,
      params
    };
  }

  private async _send(batch: object[]): Promise<RPCResponse[]> {
    const res = await fetch(this.http, {
      method: `POST`,
      headers: {
        "Content-Type": `application/json`,
      },
      body: JSON.stringify(batch),
    });
    return res.json();
  }
}

```

`zilpay.io/mixins/dex.ts`:

```ts
import type { DexPool, FieldTotalContributions, FiledBalances, FiledPools, Share } from '@/types/zilliqa';
import type { SwapPair } from '@/types/swap';

import Big from 'big.js';

import { Blockchain } from './custom-fetch';
import { ZilPayBase } from './zilpay-base';

import { $tokens, addToken, updateTokens } from '@/store/tokens';

import { formatNumber } from '@/filters/n-format';
import { addTransactions } from '@/store/transactions';
import { SHARE_PERCENT, ZERO_ADDR } from '@/config/conts';
import { $liquidity, updateDexBalances, updateLiquidity } from '@/store/shares';
import { $wallet } from '@/store/wallet';
import { $settings } from '@/store/settings';
import { TokenState } from '@/types/token';
import { $net } from '@/store/netwrok';
import { $dex } from '@/store/dex';
import { toHex } from '@/lib/to-hex';

const PROY_ZILSWAP = "0xcccfdec2c9842f3f7ece2b9be996e814d59ca0cc".toLowerCase();


Big.PE = 999;

export enum SwapDirection {
  ZilToToken,
  TokenToZil,
  TokenToTokens
}

const CONTRACTS: {
  [net: string]: string;
} = {
  'mainnet': '0x459CB2d3BAF7e61cFbD5FE362f289aE92b2BaBb0',
  'testnet': '0xb0c677b5ba660925a8f1d5d9687d0c2c379e16ee',
  'private': ''
};

export class DragonDex {
  public static FEE_DENOM = 10000n;
  public static REWARDS_DECIMALS = BigInt('100000000000');
  public static FEE_DEMON = BigInt('10000');

  private _provider = new Blockchain();

  public zilpay = new ZilPayBase();

  public get lp() {
    return $dex.state.lp;
  }

  public get fee() {
    return $dex.state.fee;
  }

  public get protoFee() {
    return $dex.state.protoFee;
  }

  public get wallet() {
    return $wallet.state;
  }

  public get contract() {
    return CONTRACTS[$net.state.net];
  }

  public get pools() {
    return $liquidity.state.pools;
  }

  public get tokens() {
    return $tokens.state.tokens;
  }

  public get liquidityRewards() {
    const fee_bp = Number(DragonDex.FEE_DENOM - this.fee); // e.g. 30
    return (fee_bp / 100); // e.g. 0.3%
  }

  public async updateState() {
    const contract = toHex(this.contract);
    const owner = String(this.wallet?.base16).toLowerCase();
    const {
      pools,
      balances,
      totalContributions,
    } = await this._provider.fetchFullState(contract, owner);
    const shares = this._getShares(balances, totalContributions, owner);
    const dexPools = this._getPools(pools);

    updateDexBalances(balances);
    updateLiquidity(shares, dexPools);
  }

  public async updateTokens() {
    const owner = String($wallet.state?.base16);
    if (!owner || owner === 'undefined') return;
    const newTokens = await this._provider.fetchTokensBalances(owner, $tokens.state.tokens);
    updateTokens(newTokens);
  }

  public async addCustomToken(token: string, owner: string) {
    const { meta, balances } = await this._provider.getToken(token, owner);
    const zp = await this.zilpay.zilpay();
    addToken({
      meta: {
        base16: meta.address,
        bech32: zp.crypto.toBech32Address(meta.address),
        symbol: meta.symbol,
        name: meta.name,
        decimals: meta.decimals,
        scope: 0
      },
      balance: balances
    });
  }

  public getRealPrice(pair: SwapPair[]): string {
    const [exactToken, limitToken] = pair;
    if (!exactToken.value || Number(exactToken.value) <= 0) {
      return '0';
    }

    const exact = this._valueToBigInt(exactToken.value, exactToken.meta);
    let value = 0n;
    
    try {
      const direction = this.getDirection(pair);
      switch (direction) {
        case SwapDirection.ZilToToken: {
          const pool = this.pools[limitToken.meta.base16];
          if (!pool) return '0';
          value = this._outputFor(exact, BigInt(pool[0]), BigInt(pool[1]));
          break;
        }
        case SwapDirection.TokenToZil: {
          const pool = this.pools[exactToken.meta.base16];
          if (!pool) return '0';
          value = this._outputFor(exact, BigInt(pool[1]), BigInt(pool[0]));
          break;
        }
        case SwapDirection.TokenToTokens: {
          const inputPool = this.pools[exactToken.meta.base16];
          const outputPool = this.pools[limitToken.meta.base16];
          if (!inputPool || !outputPool) return '0';
          
          const zilIntermediate = this._outputFor(exact, BigInt(inputPool[1]), BigInt(inputPool[0]));
          value = this._outputFor(zilIntermediate, BigInt(outputPool[0]), BigInt(outputPool[1]));
          break;
        }
      }
    } catch (err) {
        console.error("Price calculation error:", err);
        return '0';
    }
    
    return Big(value.toString()).div(this.toDecimails(limitToken.meta.decimals)).toFixed();
  }

  public getDirection(pair: SwapPair[]) {
    const [exactToken, limitToken] = pair;

    if (exactToken.meta.base16 === ZERO_ADDR && limitToken.meta.base16 !== ZERO_ADDR) {
      return SwapDirection.ZilToToken;
    } else if (exactToken.meta.base16 !== ZERO_ADDR && limitToken.meta.base16 === ZERO_ADDR) {
      return SwapDirection.TokenToZil;
    } else {
      return SwapDirection.TokenToTokens;
    }
  }

  public tokensToZil(value: string | Big, token: TokenState): Big {
    const amount = Big(value);

    try {
      const pool = this.pools[token.base16];
      if (!pool) {
        return Big(0);
      }

      const decimals = this.toDecimails(token.decimals);
      const zilDecimails = this.toDecimails(this.tokens[0].meta.decimals);
    
      const qa = amount.mul(decimals).round();

      const zilReserve = BigInt(pool[0]);
      const tokenReserve = BigInt(pool[1]);

      const zils = this._outputFor(
        BigInt(qa.toString()), 
        tokenReserve,          
        zilReserve             
      );

      return Big(zils.toString()).div(zilDecimails);
    
    } catch (err) {
      console.error("tokensToZil calculation error:", err);
      return Big(0);
    }
  }

  public async swapExactZILForTokens(exact: bigint, limit: bigint, token: TokenState) {
    const { blocks } = $settings.state;
    const limitAfterSlippage = this.afterSlippage(limit);
    const { NumTxBlocks } = await this.zilpay.getBlockchainInfo();
    const nextBlock = Big(NumTxBlocks).add(blocks);
    const params = [
      {
        vname: 'token_address',
        type: 'ByStr20',
        value: token.base16
      },
      {
        vname: 'min_token_amount',
        type: 'Uint128',
        value: String(limitAfterSlippage)
      },
      {
        vname: 'deadline_block',
        type: 'BNum',
        value: String(nextBlock)
      },
      {
        vname: 'recipient_address',
        type: 'ByStr20',
        value: String(this.wallet?.base16).toLowerCase()
      }
    ];
    const contractAddress = PROY_ZILSWAP;
    const transition = 'SwapExactZILForTokens';
    const res = await this.zilpay.call({
      params,
      contractAddress,
      transition,
      amount: String(exact)
    }, this.calcGasLimit(SwapDirection.ZilToToken).toString());

    const amount = Big(String(exact)).div(this.toDecimails(this.tokens[0].meta.decimals)).toString();
    const limitAmount = Big(String(limit)).div(this.toDecimails(token.decimals)).toString();
    addTransactions({
      timestamp: new Date().getTime(),
      name: `Swap exact (${formatNumber(amount)} ZIL), to (${formatNumber(limitAmount)} ${token.symbol})`,
      confirmed: false,
      hash: res.ID,
      from: res.from
    });

    return res;
  }

  public async swapExactTokensForZIL(exact: bigint, limit: bigint, token: TokenState) {
    const { blocks } = $settings.state;
    const limitAfterSlippage = this.afterSlippage(limit);
    const { NumTxBlocks } = await this.zilpay.getBlockchainInfo();
    const nextBlock = Big(NumTxBlocks).add(blocks);
    const params = [
      {
        vname: 'token_address',
        type: 'ByStr20',
        value: token.base16
      },
      {
        vname: 'token_amount',
        type: 'Uint128',
        value: String(exact)
      },
      {
        vname: 'min_zil_amount',
        type: 'Uint128',
        value: String(limitAfterSlippage)
      },
      {
        vname: 'deadline_block',
        type: 'BNum',
        value: String(nextBlock)
      },
      {
        vname: 'recipient_address',
        type: 'ByStr20',
        value: PROY_ZILSWAP
      }
    ];
    const contractAddress = this.contract;
    const transition = 'SwapExactTokensForZIL';
    const res = await this.zilpay.call({
      params,
      contractAddress,
      transition,
      amount: '0'
    }, this.calcGasLimit(SwapDirection.TokenToZil).toString());

    const amount = Big(String(exact)).div(this.toDecimails(token.decimals)).toString();
    const limitAmount = Big(String(limit)).div(this.toDecimails(this.tokens[0].meta.decimals)).toString();
    addTransactions({
      timestamp: new Date().getTime(),
      name: `Swap exact (${formatNumber(amount)} ${token.symbol}) to (${formatNumber(limitAmount)} ZIL)`,
      confirmed: false,
      hash: res.ID,
      from: res.from
    });

    return res;
  }

  public async swapExactTokensForTokens(exact: bigint, limit: bigint, inputToken: TokenState, outputToken: TokenState) {
    const contractAddress = this.contract;
    const { blocks } = $settings.state;
    const limitAfterSlippage = this.afterSlippage(limit);
    const { NumTxBlocks } = await this.zilpay.getBlockchainInfo();
    const nextBlock = Big(NumTxBlocks).add(blocks);
    const params = [
      {
        vname: 'token0_address',
        type: 'ByStr20',
        value: inputToken.base16
      },
      {
        vname: 'token1_address',
        type: 'ByStr20',
        value: outputToken.base16
      },
      {
        vname: 'token0_amount',
        type: 'Uint128',
        value: String(exact)
      },
      {
        vname: 'min_token1_amount',
        type: 'Uint128',
        value: String(limitAfterSlippage)
      },
      {
        vname: 'deadline_block',
        type: 'BNum',
        value: String(nextBlock)
      },
      {
        vname: 'recipient_address',
        type: 'ByStr20',
        value: String(this.wallet?.base16).toLowerCase()
      }
    ];
    const transition = 'SwapExactTokensForTokens';
    const res = await this.zilpay.call({
      params,
      contractAddress,
      transition,
      amount: '0'
    }, this.calcGasLimit(SwapDirection.TokenToTokens).toString());

    const amount = formatNumber(Big(String(exact)).div(this.toDecimails(inputToken.decimals)).toString());
    const receivedAmount = formatNumber(Big(String(limit)).div(this.toDecimails(outputToken.decimals)).toString());
    addTransactions({
      timestamp: new Date().getTime(),
      name: `Swap exact (${formatNumber(amount)} ${inputToken.symbol}) to (${formatNumber(receivedAmount)} ${outputToken.symbol})`,
      confirmed: false,
      hash: res.ID,
      from: res.from
    });

    return res;
  }

  public async addLiquidity(addr: string, amount: Big, limit: Big, created: boolean) {
    const contractAddress = this.contract;
    const { blocks } = $settings.state;
    const { blockNum, totalContributions, pool } = await this._provider.getBlockTotalContributions(
      contractAddress,
      addr
    );
    const maxExchangeRateChange = BigInt($settings.state.slippage * 100);
    const nextBlock = Big(blockNum).add(blocks);
    const maxTokenAmount = created ?
      BigInt(amount.toString()) * (DragonDex.FEE_DEMON + maxExchangeRateChange) / DragonDex.FEE_DEMON : BigInt(amount.toString());
    let minContribution = BigInt(0);

    if (created) {
      const zilAmount = BigInt(limit.toString());
      const zilReserve = Big(pool[0]);
      const totalContribution = BigInt(totalContributions);
      const numerator = totalContribution * zilAmount;
      const denominator = Big(String(DragonDex.FEE_DEMON + maxExchangeRateChange)).sqrt().mul(zilReserve).round();
      minContribution = numerator / BigInt(String(denominator));
    }

    const params = [
      {
        vname: 'token_address',
        type: 'ByStr20',
        value: addr
      },
      {
        vname: 'min_contribution_amount',
        type: 'Uint128',
        value: String(minContribution)
      },
      {
        vname: 'max_token_amount',
        type: 'Uint128',
        value: String(maxTokenAmount)
      },
      {
        vname: 'deadline_block',
        type: 'BNum',
        value: String(nextBlock)
      }
    ];
    const transition = 'AddLiquidity';
    const res = await this.zilpay.call({
      params,
      contractAddress,
      transition,
      amount: String(limit)
    }, '5060');

    const found = this.tokens.find((t) => t.meta.base16 === addr);

    if (found) {
      const max = amount.div(this.toDecimails(found.meta.decimals)).toString();
      addTransactions({
        timestamp: new Date().getTime(),
        name: `addLiquidity maximum ${formatNumber(max)} ${found.meta.symbol}`,
        confirmed: false,
        hash: res.ID,
        from: res.from
      });
    }

    return res.ID;
  }

  public async removeLiquidity(minzil: Big, minzrc: Big, minContributionAmount: Big, token: string, owner: string) {
    const contractAddress = this.contract;
    const { blocks } = $settings.state;
    const { blockNum } = await this._provider.getUserBlockTotalContributions(
      contractAddress,
      token,
      owner
    );
    const zilsAfterSlippage = this.afterSlippage(BigInt(String(minzil)));
    const tokensAfterSlippage = this.afterSlippage(BigInt(String(minzrc)));
    const nextBlock = Big(blockNum).add(blocks);
    const params = [
      {
        vname: 'token_address',
        type: 'ByStr20',
        value: token
      },
      {
        vname: 'contribution_amount',
        type: 'Uint128',
        value: String(minContributionAmount)
      },
      {
        vname: 'min_zil_amount',
        type: 'Uint128',
        value: String(zilsAfterSlippage)
      },
      {
        vname: 'min_token_amount',
        type: 'Uint128',
        value: String(tokensAfterSlippage)
      },
      {
        vname: 'deadline_block',
        type: 'BNum',
        value: String(nextBlock)
      }
    ];
    const transition = 'RemoveLiquidity';
    const res = await this.zilpay.call({
      params,
      contractAddress,
      transition,
      amount: '0'
    }, '3060');

    addTransactions({
      timestamp: new Date().getTime(),
      name: `RemoveLiquidity`,
      confirmed: false,
      hash: res.ID,
      from: res.from
    });

    return res;
  }

  public toDecimails(decimals: number) {
    return Big(10**decimals);
  }

  public afterSlippage(amount: bigint) {
    const slippage = $settings.state.slippage;

    if (slippage <= 0) {
      return amount;
    }

    const _slippage = DragonDex.FEE_DEMON - BigInt(slippage * 100);

    return amount * _slippage / DragonDex.FEE_DEMON;
  }

  public calcGasLimit(direction: SwapDirection) {
    switch (direction) {
      case SwapDirection.ZilToToken:
        return Big(4637);
      case SwapDirection.TokenToZil:
        return Big(5163);
      case SwapDirection.TokenToTokens:
        return Big(6183);
      default:
        return Big(7000);
    }
  }

  public calcPriceImpact(priceInput: Big, priceOutput: Big, currentPrice: Big) {
    const nextPrice = priceInput.div(priceOutput);
    const priceDiff = nextPrice.sub(currentPrice);
    const value = priceDiff.div(currentPrice);
    const _100 = Big(100);
    const imact = value.mul(_100).round(3).toNumber();
    const v = Math.abs(imact);

    return v > 100 ? 100 : v;
  }

  public calcVirtualAmount(amount: Big, token: TokenState, pool: string[]) {
    if (!pool || pool.length < 2) {
      return Big(0);
    }

    const zilReserve = Big(String(pool[0])).div(this.toDecimails($tokens.state.tokens[0].meta.decimals));
    const tokensReserve = Big(String(pool[1])).div(this.toDecimails(token.decimals));
    const zilRate = zilReserve.div(tokensReserve);

    return amount.mul(zilRate);
  }

  public sleepageCalc(value: string) {
    const slippage = $settings.state.slippage;

    if (slippage <= 0) {
      return value;
    }

    const amount = Big(value);
    const demon = Big(String(DragonDex.FEE_DEMON));
    const slip = demon.sub(slippage * 100);

    return amount.mul(slip).div(demon);
  }

  private _fraction(d: bigint, x: bigint, y: bigint) {
    return (d * y) / x;
  }

  private _zilToTokens(amount: bigint, inputPool: string[]): bigint {
    const [zilReserve, tokenReserve] = inputPool;

    return this._outputFor(
    amount,                 
    BigInt(zilReserve),     
    BigInt(tokenReserve)    
    );
  }

  private _tokensToZil(amount: bigint, inputPool: string[], cashback: boolean) {
    const [zilReserve, tokenReserve] = inputPool;
    const zils = this._outputFor(amount, BigInt(tokenReserve), BigInt(zilReserve));

    return (this.protoFee === BigInt(0) || !cashback) ? zils : zils - (zils / this.protoFee);
  }

  private _tokensToTokens(amount: bigint, inputPool: string[], outputPool: string[], cashback: boolean) {
    const [inputZilReserve, inputTokenReserve] = inputPool;
    const [outputZilReserve, outputTokenReserve] = outputPool;
    const fee = DragonDex.FEE_DEMON - ((DragonDex.FEE_DEMON - this.fee) / BigInt(2));
    const zilIntermediateAmount = this._outputFor(
      amount,
      BigInt(inputTokenReserve),
      BigInt(inputZilReserve),
      fee
    );

    const zils = (this.protoFee === BigInt(0) || !cashback) ?
      zilIntermediateAmount : zilIntermediateAmount - (zilIntermediateAmount / this.protoFee);

    return this._outputFor(zils, BigInt(outputZilReserve), BigInt(outputTokenReserve), fee);
  }

  private _outputFor(exactAmount: bigint, inputReserve: bigint, outputReserve: bigint, fee: bigint = this.fee) {
    const exactAmountAfterFee = exactAmount * fee;
    const numerator = exactAmountAfterFee * outputReserve;
    const inputReserveAfterFee = inputReserve * DragonDex.FEE_DEMON;
    const denominator = inputReserveAfterFee + exactAmountAfterFee;

    return numerator / denominator;
  }

  private _getShares(balances: FiledBalances, totalContributions: FieldTotalContributions, owner: string): Share {
    const shares: Share = {};
    const _zero = BigInt(0);
    const userContributions = balances;

    for (const token in userContributions) {
      try {
        const contribution = BigInt(totalContributions[token]);
        const balance = BigInt(userContributions[token][owner.toLowerCase()]);

        if (balance === _zero) {
          continue;
        }

        shares[token] = (balance * SHARE_PERCENT) / contribution;
      } catch {
        ///        
      }
    }

    return shares;
  }

  private _getPools(pools: FiledPools) {
    const newPools: DexPool = {};

    for (const token in pools) {
      const [x, y] = pools[token].arguments;

      newPools[token] = [x, y];
    }

    return newPools;
  }

  private _valueToBigInt(amount: string, token: TokenState) {
    return BigInt(
      Big(amount).mul(this.toDecimails(token.decimals)).round().toString()
    );
  }
}

```

`zilpay.io/mixins/token.ts`:

```ts
import { addTransactions } from "@/store/transactions";
import { Blockchain } from "./custom-fetch";
import { ZilPayBase } from "./zilpay-base";

export class TokensMixine {
  private _provider = new Blockchain();

  public zilpay = new ZilPayBase();

  public isAllow(value: string, allowances: string) {
    const bigValue = BigInt(value);
    const bigAllow = BigInt(allowances);

    return bigValue < bigAllow;
  }

  public async getAllowances(spender: string, contract: string): Promise<bigint> {
    const field = `allowances`;
    const zilpay = await this.zilpay.zilpay();
    if (!zilpay.wallet.isEnable) {
      await zilpay.wallet.connect();
    }
    const owner = String(zilpay.wallet.defaultAccount?.base16).toLowerCase();
    const address = spender.toLowerCase();
    const result = await this.zilpay.getSubState(contract, field, [
      owner,
      address
    ]);

    if (result && result[owner] && result[owner][address]) {
      return BigInt(result[owner][address]);
    }

    return BigInt(0);
  }

  public async increaseAllowance(spender: string, token: string, balance: string) {
    const params = [
      {
        vname: `spender`,
        type: `ByStr20`,
        value: String(spender),
      },
      {
        vname: `amount`,
        type: `Uint128`,
        value: String(balance),
      },
    ];
    const transition = `IncreaseAllowance`;
    const res = await this.zilpay.call({
      transition,
      params,
      amount: `0`,
      contractAddress: token
    });

    addTransactions({
      timestamp: new Date().getTime(),
      name: `Approve token`,
      confirmed: false,
      hash: res.ID,
      from: res.from
    });

    return res;
  }
}

```

`zilpay.io/mixins/zilpay-base.ts`:

```ts
type Params = {
  contractAddress: string;
  transition: string;
  params: object[];
  amount: string;
};

const window = global.window as any;
export const DEFAUL_GAS = {
  gasPrice: `2500`,
  gaslimit: `5000`,
};
export class ZilPayBase {
  public zilpay: () => Promise<any>;

  constructor() {
    this.zilpay = () => new Promise((resolve, reject) => {
      if (!process.browser) {
        return resolve({} as any);
      }
      let k = 0;
      const i = setInterval(() => {
        if (k >= 10) {
          clearInterval(i);
          return reject(new Error(`ZIlPay is not installed.`));
        }

        if (typeof window.zilPay !== `undefined`) {
          clearInterval(i);
          return resolve(window.zilPay);
        }

        k++;
      }, 100);
    });
  }

  async getSubState(contract: string, field: string, params: string[] = []) {
    if (!process.browser) {
      return null;
    }

    const zilPay = await this.zilpay();
    const res = await zilPay.blockchain.getSmartContractSubState(
      contract,
      field,
      params,
    );

    if (!res) {
      throw new Error('ZIlPay is not loaded yet');
    }

    if (res.error) {
      throw new Error(res.error.message);
    }

    if (res.result && res.result[field] && params.length === 0) {
      return res.result[field];
    }

    if (res.result && res.result[field] && params.length === 1) {
      const [arg] = params;
      return res.result[field][arg];
    }

    if (res.result && res.result[field] && params.length > 1) {
      return res.result[field];
    }

    return null;
  }

  async getState(contract: string) {
    if (!process.browser) {
      return null;
    }
    const zilPay = await this.zilpay();
    const res = await zilPay.blockchain.getSmartContractState(contract);

    if (!res) {
      throw new Error('ZIlPay is not loaded yet');
    }

    if (res.error) {
      throw new Error(res.error.message);
    }

    return res.result;
  }

  async getBlockchainInfo() {
    if (!process.browser) {
      return null;
    }

    const zilPay = await this.zilpay();
    const { error, result } = await zilPay.blockchain.getBlockChainInfo();

    if (error) {
      throw new Error(error.message);
    }

    return result;
  }

  async call(data: Params, gaslimit = DEFAUL_GAS.gaslimit) {
    const zilPay = await this.zilpay();
    const { contracts, utils } = zilPay;
    const contract = contracts.at(data.contractAddress);
    const gasPrice = utils.units.toQa(DEFAUL_GAS.gasPrice, utils.units.Units.Li);
    const gasLimit = utils.Long.fromNumber(gaslimit);
    const amount = data.amount || `0`;

    return await contract.call(data.transition, data.params, {
      amount,
      gasPrice,
      gasLimit,
    });
  }
}

```

`zilpay.io/next-env.d.ts`:

```ts
/// <reference types="next" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

```

`zilpay.io/pages/_app.tsx`:

```tsx
import '../styles/globals.scss';

import React from 'react';
import Cookies from 'cookies';
import { appWithTranslation } from 'next-i18next'
import NextNprogress from "nextjs-progressbar";

import { Footer } from '@/components/footer';
import { NavBar } from '@/components/nav-bar/index';
import { Themes } from '@/config/themes';
import { $settings, updateSettingsStore, updateFromStorage } from '@/store/settings';
import { initZilPayWeb3 } from '@zilpay/zilpay-web3';

updateFromStorage();

const App = ({ Component, pageProps }: any) => {
  React.useEffect(() => {
    if (globalThis.document) {
      initZilPayWeb3();
    }
  }, []);

  return (
    <>
      <NextNprogress
        color="var(--primary-color)"
        startPosition={0.3}
        stopDelayMs={200}
        height={3}
        showOnShallow
      />
      <NavBar />
      <Component {...pageProps} />
      <Footer />
    </>
  );
}

App.getInitialProps = async function({ ctx }: any): Promise<{}> {
  const cookies = new Cookies(ctx.req, ctx.res);
  const theme = cookies.get('theme') || Themes.Dark;

  updateSettingsStore({
    ...$settings.state,
    theme
  });

  return {
    theme
  };
}

export default appWithTranslation(App);

```

`zilpay.io/pages/_document.tsx`:

```tsx
import { Themes } from '@/config/themes';
import Document, { Html, Head, Main, NextScript } from 'next/document';

class ZilPayDocument extends Document {

  render() {
    return (
      <Html>
        <Head>
          {this.props.__NEXT_DATA__.props.theme === Themes.Light ? (
            <meta name="theme-color" content="#1a5d8d" media="(prefers-color-scheme: dark)" />
            ) : (
            <meta name="theme-color" content="#fff" media="(prefers-color-scheme: light)" />
          )}
          <link rel="icon" type="image/x-icon" href="/favicon/favicon.ico" />
          <link rel="apple-touch-icon" type="image/png" sizes="57x57" href="/favicon/apple-icon-57x57.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="60x60" href="/favicon/apple-icon-60x60.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="72x72" href="/favicon/apple-icon-72x72.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="/favicon/apple-icon-76x76.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="114x114" href="/favicon/apple-icon-114x114.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="/favicon/apple-icon-120x120.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="144x144" href="/favicon/apple-icon-144x144.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="152x152" href="/favicon/apple-icon-152x152.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="/favicon/apple-icon-180x180.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="192x192" href="/favicon/apple-icon-192x192.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="32x32" href="/favicon/apple-icon-32x32.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="96x96" href="/favicon/apple-icon-96x96.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="16x16" href="/favicon/apple-icon-16x16.png" />
          <link rel="apple-touch-icon" type="image/png" sizes="200x200" href="/favicon/ms-icon-200x200.png" />
          <link rel="manifest" href="/favicon/manifest.json" />
        </Head>
        <body theme-color={this.props.__NEXT_DATA__.props.theme}>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default ZilPayDocument;

```

`zilpay.io/pages/dex-policy.tsx`:

```tsx
import styles from '@/styles/pages/policy.module.scss';

import { useTranslation } from 'next-i18next';
import React from 'react';
import Head from 'next/head';
import { GetServerSidePropsContext, NextPage } from 'next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';


export const ExtensionPolicyPage: NextPage = () => {
  const { t } = useTranslation(`dex-policy`);

  return (
    <div className={styles.policy}>
      <Head>
        <title>{t(`head_title`)}</title>
        <meta
          property="og:title"
          content={t(`head_title`)}
          key="title"
        />
      </Head>
      <div className={styles.dummy}/>
      <div className={styles.wrapper}>
        <p>
          {t(`last_update`)}
        </p>
        <h1>
          {t(`head_title`)}
        </h1>
        <p>
          {t(`part0.p0`)}
        </p>
        <p>
          {t(`part0.p1`)}
        </p>
        <p>
          {t(`part0.p2`)}
        </p>
        <h4>
          {t(`part1.title`)}
        </h4>
        <p>
          {t(`part1.p0`)}
        </p>
        <h4>
          {t(`part2.title`)}
        </h4>
        <p>
          {t(`part2.p0`)}
        </p>
        <p>
          {t(`part2.p1`)}
        </p>
        <h4>
          {t(`part3.title`)}
        </h4>
        <p>
          {t(`part3.p0`)}
        </p>
        <h4>
          {t(`part4.title`)}
        </h4>
        <p>
          {t(`part4.p0`)}
        </p>
        <h4>
          {t(`part5.title`)}
        </h4>
        <p>
          {t(`part5.p0`)}
        </p>
        <p>
          {t(`part5.p1`)}
        </p>
        <p>
          {t(`part5.p2`)}
        </p>
        <h4>
          {t(`part6.title`)}
        </h4>
        <p>
          {t(`part6.p0`)}
        </p>
        <p>
          {t(`part6.p1`)}
        </p>
        <p>
          {t(`part6.p2`)}
        </p>
        <p>
          {t(`part6.p3`)}
        </p>
        <p>
          {t(`part6.p4`)}
        </p>
        <p>
          {t(`part6.p5`)}
        </p>
        <p>
          {t(`part6.p6`)}
        </p>
        <p>
          {t(`part6.p7`)}
        </p>
        <p>
          {t(`part6.p8`)}
        </p>
        <h4>
          {t(`part7.title`)}
        </h4>
        <p>
          {t(`part7.p0`)}
        </p>
        <p>
          {t(`part7.p1`)}
        </p>
        <h4>
          {t(`part8.title`)}
        </h4>
        <p>
          {t(`part8.p0`)}
        </p>
        <h4>
          {t(`part9.title`)}
        </h4>
        <p>
          {t(`part9.p0`)}
        </p>
        <h4>
          {t(`part10.title`)}
        </h4>
        <p>
          {t(`part10.p0`)}
        </p>
        <h4>
          {t(`part11.title`)}
        </h4>
        <p>
          {t(`part11.p0`)}
        </p>
        <p>
          {t(`part11.p1`)}
        </p>
        <h4>
          {t(`part12.title`)}
        </h4>
        <p>
          {t(`part12.p0`)}
        </p>
        <h4>
          {t(`part13.title`)}
        </h4>
        <p>
          {t(`part13.p0`)}
        </p>
        <h4>
          {t(`part14.title`)}
        </h4>
        <p>
          {t(`part14.p0`)}
        </p>
        <h4>
          {t(`part15.title`)}
        </h4>
        <p>
          {t(`part15.p0`)}
        </p>
        <h4>
          {t(`part16.title`)}
        </h4>
        <p>
          {t(`part16.p0`)}
        </p>
        <h4>
          {t(`part17.title`)}
        </h4>
        <p>
          {t(`part17.p0`)}
        </p>
      </div>
    </div>
  );
};

export const getStaticProps = async (props: GetServerSidePropsContext) => ({
    props: {
      ...await serverSideTranslations(props.locale || `en`, [`dex-policy`, `common`]),
    },
  });

export default ExtensionPolicyPage;

```

`zilpay.io/pages/extension-policy.tsx`:

```tsx
import styles from '@/styles/pages/policy.module.scss';

import { useTranslation } from 'next-i18next';
import React from 'react';
import Head from 'next/head';
import { GetServerSidePropsContext, NextPage } from 'next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';


export const ExtensionPolicyPage: NextPage = () => {
  const { t } = useTranslation(`extension-policy`);

  return (
    <div className={styles.policy}>
      <Head>
        <title>{t(`head_title`)}</title>
        <meta
          property="og:title"
          content={t(`head_title`)}
          key="title"
        />
      </Head>
      <div className={styles.dummy}/>
      <div className={styles.wrapper}>
        <p className={styles.muted}>
          {t(`last_update`)}
        </p>
        <h1>
          {t(`head_title`)}
        </h1>
        <p>
          <strong>
            {t(`title0`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p0`)}
        </p>
        <p className={styles.muted}>
          {t(`p1`)}
        </p>
        <p className={styles.muted}>
          {t(`p2`)}
        </p>
        <p className={styles.muted}>
          {t(`p3`)}
        </p>
        <p>
          <strong>
            {t(`title1`)}
          </strong>
        </p>
        <ul>
          <li>
            <p className={styles.muted}>
              {t(`collections0`)}
            </p>
          </li>
          <li>
            <p className={styles.muted}>
              {t(`collections1`)}
            </p>
          </li>
        </ul>
        <p>
          <strong>
            {t(`title2`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p4`)}
        </p>
        <p>
          <strong>
            {t(`title3`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p5`)}
        </p>
        <p className={styles.muted}>
          {t(`p6`)}
        </p>
        <p className={styles.muted}>
          {t(`p7`)}
        </p>
        <p className={styles.muted}>
          {t(`p8`)}
        </p>
        <p>
          <strong>
            {t(`title4`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p9`)}
        </p>
        <p>
          {t(`p10`)}
        </p>
        <p>
          <strong>
            {t(`title5`)}
          </strong>
        </p>
        <ul>
          <li>
            <p className={styles.muted}>
              {t(`stores0`)}
            </p>
          </li>
          <li>
            <p className={styles.muted}>
              {t(`stores1`)}
            </p>
          </li>
          <li>
            <p className={styles.muted}>
              {t(`stores2`)}
            </p>
          </li>
          <li>
            <p className={styles.muted}>
              {t(`stores3`)}
            </p>
          </li>
          <li>
            <p className={styles.muted}>
              {t(`stores4`)}
            </p>
          </li>
          <li>
            <p className={styles.muted}>
              {t(`stores5`)}
            </p>
          </li>
        </ul>
        <p>
          <strong>
            {t(`title6`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p11`)}
        </p>
        <p>
          <strong>
            {t(`title7`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p12`)}
        </p>
        <p>
          <strong>
            {t(`title8`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p13`)}
        </p>
        <p>
          <strong>
            {t(`title9`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p14`)}
        </p>
      </div>
    </div>
  );
};

export const getStaticProps = async (props: GetServerSidePropsContext) => ({
    props: {
      ...await serverSideTranslations(props.locale || `en`, [`extension-policy`, `common`]),
    },
  });

export default ExtensionPolicyPage;

```

`zilpay.io/pages/index.tsx`:

```tsx
import styles from '@/styles/pages/main.module.scss';

import type { NextPage } from 'next';

import Image from "next/image";
import Head from 'next/head';
import React from 'react';
import { GetServerSidePropsContext } from 'next';
import { useTranslation } from 'next-i18next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';
import { InfoCard } from '@/components/info-card';

import { AppLinks } from '@/config/links';
import GitHubIcon from '@/components/icons/github';
import LinkedinIcon from '@/components/icons/linkedin';
import TwitterIcon from '@/components/icons/twitter';
import { SmartButton } from '@/components/smart-button';

type Prop = {
  userAgent: string;
};

const MainPage: NextPage<Prop> = (props) => {
  const { t } = useTranslation(`main`);

  return (
    <>
      <Head>
        <title>{t(`head_title`)}</title>
        <meta
          property="og:title"
          content={t(`head_title`)}
          key="title"
        />
      </Head>
      <section className={styles.main}>
        <div className={styles.wrapper}>
          <h1>
            {t('main.title')}
          </h1>
          <h2>
            {t('main.sub_title')}
          </h2>
        </div>
        <div className={styles.btns}>
          <a href={AppLinks.IOS}>
            <div className={styles.iosbtn}/>
          </a>
          <a href={AppLinks.GOOGLE}>
            <div className={styles.googlebtn}/>
          </a>
          <a href={AppLinks.RUSTORE}>
            <div className={styles.rustorebtn}/>
          </a>
          <a href={AppLinks.APPGALLERY}>
            <div className={styles.appgallerybtn}/>
          </a>
          <a href={AppLinks.APK}>
            <div className={styles.apkbtn}/>
          </a>
        </div>
        <SmartButton userAgent={props.userAgent}/>
      </section>
      <section className={styles.features}>
        <div className={styles.cards}>
          <InfoCard
              url="/icons/info-0.svg"
              title={t(`info.card_0.title`)}
            >
              {t(`info.card_0.sub_title`)}
            </InfoCard>
            <InfoCard
              url="/icons/info-1.svg"
              title={t(`info.card_1.title`)}
              selected
            >
              {t(`info.card_1.sub_title`)}
            </InfoCard>
            <InfoCard
              url="/icons/info-2.svg"
              title={t(`info.card_2.title`)}
            >
              {t(`info.card_2.sub_title`)}
            </InfoCard>
        </div>
      </section>
      <section className={styles.features}>
        <div className={styles.header}>
          <h1>
            {t(`features.title`)}
          </h1>
          <p>
            {t(`features.sub_title`)}
          </p>
        </div>
        <div className={styles.cards}>
          <InfoCard
            url="/icons/wallet.svg"
            title={t(`features.card_0.title`)}
          >
            {t(`features.card_0.sub_title`)}
          </InfoCard>
          <InfoCard
            url="/icons/location.svg"
            title={t(`features.card_1.title`)}
          >
            {t(`features.card_1.sub_title`)}
          </InfoCard>
          <InfoCard
            url="/icons/key.svg"
            title={t(`features.card_2.title`)}
          >
            {t(`features.card_2.sub_title`)}
          </InfoCard>
          <InfoCard
            url="/icons/lock.svg"
            title={t(`features.card_3.title`)}
          >
            {t(`features.card_3.sub_title`)}
          </InfoCard>
          <InfoCard
            url="/icons/settings.svg"
            title={t(`features.card_4.title`)}
          >
            {t(`features.card_4.sub_title`)}
          </InfoCard>
          <InfoCard
            url="/icons/rokket.svg"
            title={t(`features.card_5.title`)}
          >
            {t(`features.card_5.sub_title`)}
          </InfoCard>
        </div>
      </section>
      <section className={styles.team}>
        <div className={styles.header}>
          <h1>
            {t(`team.title`)}
          </h1>
        </div>
        <div className={styles.teamwrapp}>
          <div className={styles.teamcard}>
            <Image
              src="/images/rinat.webp"
              alt="me"
              height={200}
              width={200}
            />
            <h3>
              Rinat Khasanshin
            </h3>
            <p>
              CO-FOUNDER & CEO
            </p>
            <hr />
            <div>
              <a
                href="https://github.com/hicaru"
                target="_blank"
                rel="noreferrer"
              >
                <GitHubIcon
                  height={15}
                  width={15}
                  color="var(--muted-color)"
                />
              </a>
              <a
                href="https://www.linkedin.com/in/arc-warden/"
                target="_blank"
                rel="noreferrer"
              >
                <LinkedinIcon
                  height={15}
                  width={15}
                  color="var(--muted-color)"
                />
              </a>
              <a
                href="https://twitter.com/lich666black"
                target="_blank"
                rel="noreferrer"
              >
                <TwitterIcon
                  height={15}
                  width={15}
                  color="var(--muted-color)"
                />
              </a>
            </div>
          </div>
        </div>
      </section>
    </>
  )
};


export async function getServerSideProps(context: GetServerSidePropsContext) {
  let userAgent;

  if (context.req) { // if you are on the server and you get a 'req' property from your context
    userAgent = context.req.headers['user-agent'] // get the user-agent from the headers
  } else {
    userAgent = navigator.userAgent // if you are on the client you can access the navigator from the window object
  }

  return {
    props: {
      userAgent,
      ...await serverSideTranslations(context.locale || `en`, [`main`, `common`]),
    }
  }
}



export default MainPage;

```

`zilpay.io/pages/policy.tsx`:

```tsx
import styles from '@/styles/pages/policy.module.scss';

import { useTranslation } from 'next-i18next';
import React from 'react';
import Head from 'next/head';
import { GetServerSidePropsContext, NextPage } from 'next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';


export const PolicyPage: NextPage = () => {
  const { t } = useTranslation(`policy`);

  return (
    <div className={styles.policy}>
      <Head>
        <title>{t(`head_title`)}</title>
        <meta
          property="og:title"
          content={t(`head_title`)}
          key="title"
        />
      </Head>
      <div className={styles.dummy}/>
      <div className={styles.wrapper}>
        <p className={styles.muted}>
          {t(`last_update`)}
        </p>
        <h1>
          {t(`title`)}
        </h1>
        <p className={styles.muted}>
          {t(`p0`)}
        </p>
        <p className={styles.muted}>
          {t(`p1`)}
        </p>
        <p className={styles.muted}>
          {t(`p2`)}
        </p>
        <p className={styles.muted}>
          {t(`p3`)}
        </p>
        <p>
          <strong>
            {t(`sub_title4`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p5`)}
        </p>
        <p>
          <strong>
            {t(`sub_title6`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p7`)}
        </p>
        <p className={styles.muted}>
          {t(`p8`)}
        </p>
        <p className={styles.muted}>
          {t(`p9`)}
        </p>
        <p className={styles.muted}>
          {t(`p10`)}
        </p>
        <p className={styles.muted}>
          {t(`p11`)}
        </p>
        <p className={styles.muted}>
          {t(`p12`)}
        </p>
        <p className={styles.muted}>
          {t(`p13`)}
        </p>
        <p>
          <strong>
            {t(`sub_title14`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p15`)}
        </p>
        <p className={styles.muted}>
          {t(`p16`)}
        </p>
        <p className={styles.muted}>
          {t(`p17`)}
        </p>
        <p className={styles.muted}>
          {t(`p18`)}
        </p>
        <p className={styles.muted}>
          {t(`p19`)}
        </p>
        <p className={styles.muted}>
          {t(`p20`)}
        </p>
        <p className={styles.muted}>
          {t(`p21`)}
        </p>
        <p className={styles.muted}>
          {t(`p22`)}
        </p>
        <p className={styles.muted}>
          {t(`p23`)}
        </p>
        <p className={styles.muted}>
          {t(`p24`)}
        </p>
        <p className={styles.muted}>
          {t(`p25`)}
        </p>
        <p className={styles.muted}>
          {t(`p26`)}
        </p>
        <p className={styles.muted}>
          {t(`p27`)}
        </p>
        <p className={styles.muted}>
          {t(`p28`)}
        </p>
        <p className={styles.muted}>
          {t(`p29`)}
        </p>
        <p>
          <strong>
            {t(`sub_title30`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p31`)}
        </p>
        <p className={styles.muted}>
          {t(`p32`)}
        </p>
        <p>
          <strong>
            {t(`sub_title33`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p34`)}
        </p>
        <p className={styles.muted}>
          {t(`p35`)}
        </p>
        <p className={styles.muted}>
          {t(`p36`)}
        </p>
        <p>
          <strong>
            {t(`sub_title37`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p38`)}
        </p>
        <p className={styles.muted}>
          {t(`p39`)}
        </p>
        <p className={styles.muted}>
          {t(`p40`)}
        </p>
        <p>
          <strong>
            {t(`sub_title41`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p42`)}
        </p>
        <p className={styles.muted}>
          {t(`p43`)}
        </p>
        <p className={styles.muted}>
          {t(`p44`)}
        </p>
        <p>
          <strong>
            {t(`sub_title45`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p46`)}
        </p>
        <p className={styles.muted}>
          {t(`p47`)}
        </p>
        <p className={styles.muted}>
          {t(`p48`)}
        </p>
        <p className={styles.muted}>
          {t(`p49`)}
        </p>
        <p className={styles.muted}>
          {t(`p50`)}
        </p>
        <p>
          <strong>
            {t(`sub_title51`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p52`)}
        </p>
        <p className={styles.muted}>
          {t(`p53`)}
        </p>
        <p>
          <strong>
            {t(`sub_title54`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p55`)}
        </p>
        <p className={styles.muted}>
          {t(`p56`)}
        </p>
        <p>
          <strong>
            {t(`sub_title57`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p58`)}
        </p>
        <p className={styles.muted}>
          {t(`p59`)}
        </p>
        <p>
          <strong>
            {t(`sub_title60`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p61`)}
        </p>
        <p className={styles.muted}>
          {t(`p62`)}
        </p>
        <p className={styles.muted}>
          {t(`p63`)}
        </p>
        <p className={styles.muted}>
          {t(`p64`)}
        </p>
        <p>
          <strong>
            {t(`sub_title65`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p66`)}
        </p>
        <p className={styles.muted}>
          {t(`p67`)}
        </p>
        <p className={styles.muted}>
          {t(`p68`)}
        </p>
      </div>
    </div>
  );
};

export const getStaticProps = async (props: GetServerSidePropsContext) => ({
    props: {
      ...await serverSideTranslations(props.locale || `en`, [`policy`, `common`]),
    },
  });

export default PolicyPage;

```

`zilpay.io/pages/pool/[addr].tsx`:

```tsx
import styles from '@/styles/pages/swap.module.scss';

import type { ListedTokenResponse } from '@/types/token';

import Head from 'next/head';
import { useRouter } from 'next/router';
import { useStore } from 'react-stores';
import { useTranslation } from 'next-i18next';
import React from 'react';
import { GetServerSidePropsContext, NextPage } from 'next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';

import { RemovePoolForm } from '@/components/pool';
import { $tokens, loadFromServer } from '@/store/tokens';

import { DragonDex } from '@/mixins/dex';
import { ThreeDots } from 'react-loader-spinner';
import { ZilPayBackend } from '@/mixins/backend';
import { updateRate } from '@/store/settings';
import { updateDexPools } from '@/store/shares';
import { $wallet } from '@/store/wallet';


type Prop = {
  data: ListedTokenResponse;
};


const backend = new ZilPayBackend();
const dex = new DragonDex();

export const PageRemovePool: NextPage<Prop> = (props) => {
  const pool = useTranslation(`pool`);

  const router = useRouter();
  const tokensStore = useStore($tokens);
  const wallet = useStore($wallet);

  const token = React.useMemo(() => {
    return tokensStore.tokens.find(
      (t) => t.meta.base16 === String(router.query.addr).toLowerCase()
    );
  }, [tokensStore, router]);

  React.useEffect(() => {
    if (props.data) {
      updateDexPools(props.data.pools);
      updateRate(props.data.rate);
      loadFromServer(props.data.tokens.list);
    }
  }, [props]);

  React.useEffect(() => {
    if (wallet) {
      dex.updateState();
    }
  }, [wallet]);

  return (
    <div className={styles.container}>
      <Head>
        <title>{pool.t('remove_pool.head')}</title>
        <meta
          property="og:title"
          content={pool.t('remove_pool.title')}
          key="title"
        />
      </Head>
      <div>
        {token ? (
          <RemovePoolForm token={token} />
        ) : (
          <ThreeDots color='var(--text-color)'/>
        )}
      </div>
    </div>
  );
};

export const getServerSideProps = async (context: GetServerSidePropsContext) => {
  if (context.res) {
    // res available only at server
    // no-store disable bfCache for any browser. So your HTML will not be cached
    context.res.setHeader(`Cache-Control`, `no-store`);
  }

  const data = await backend.getListedTokens();
  
  updateDexPools(data.pools);
  updateRate(data.rate);
  loadFromServer(data.tokens.list);

  return {
    props: {
      data,
      ...await serverSideTranslations(context.locale || `en`, [`pool`, `common`])
    }
  };
};

export default PageRemovePool;

```

`zilpay.io/pages/pool/add.tsx`:

```tsx
import styles from '@/styles/pages/swap.module.scss';

import type { ListedTokenResponse } from '@/types/token';

import Head from 'next/head';
import React from 'react';
import { useTranslation } from 'next-i18next';
import { GetServerSidePropsContext, NextPage } from 'next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';

import { AddPoolForm } from '@/components/pool';

import { DragonDex } from '@/mixins/dex';
import { ZilPayBackend } from '@/mixins/backend';
import { updateRate } from '@/store/settings';
import { $tokens, loadFromServer } from '@/store/tokens';
import { updateDexPools } from '@/store/shares';
import { useStore } from 'react-stores';
import { $wallet } from '@/store/wallet';


type Prop = {
  data: ListedTokenResponse;
  index: number;
};


const backend = new ZilPayBackend();
const dex = new DragonDex();
export const PageAddPool: NextPage<Prop> = (props) => {
  const pool = useTranslation(`pool`);

  const wallet = useStore($wallet);

  const hanldeUpdate = React.useCallback(async() => {
    if (typeof window !== 'undefined') {
      try {
        await dex.updateTokens();
        await dex.updateState();
      } catch {
        ///
      }
    }
  }, []);

  React.useEffect(() => {
    if (props.data) {
      updateDexPools(props.data.pools);
      updateRate(props.data.rate);
      loadFromServer(props.data.tokens.list);
    }
  }, [props]);

  React.useEffect(() => {
    if (wallet) {
      hanldeUpdate();
    }
  }, [hanldeUpdate, wallet]);

  return (
    <div className={styles.container}>
      <Head>
        <title>{pool.t('add_pool.head')}</title>
        <meta
          property="og:title"
          content={pool.t('add_pool.title')}
          key="title"
        />
      </Head>
      <div>
        <AddPoolForm index={props.index}/>
      </div>
    </div>
  );
};

export const getServerSideProps = async (context: GetServerSidePropsContext) => {
  let index = 1;
  const data = await backend.getListedTokens();

  updateDexPools(data.pools);
  updateRate(data.rate);
  loadFromServer(data.tokens.list);

  if (context.query) {
    if (context.query['token']) {
      const foundIndex = data.tokens.list.findIndex((t) => t.bech32 === context.query['token']);

      if (foundIndex >= 1) {
        index = foundIndex;
      }
    }
  }

  return {
    props: {
      data,
      index,
      ...await serverSideTranslations(context.locale || `en`, [`pool`, `common`])
    }
  };
};

export default PageAddPool;

```

`zilpay.io/pages/pool/index.tsx`:

```tsx
import styles from '@/styles/pages/swap.module.scss';

import type { ListedTokenResponse } from '@/types/token';

import Head from 'next/head';
import { useTranslation } from 'next-i18next';
import React from 'react';
import { GetServerSidePropsContext, NextPage } from 'next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';

import { PoolOverview } from '@/components/pool';
import { DragonDex } from '@/mixins/dex';

import { ZilPayBackend } from '@/mixins/backend';
import { updateRate } from '@/store/settings';
import { loadFromServer } from '@/store/tokens';
import { updateDexPools } from '@/store/shares';
import { useStore } from 'react-stores';
import { $wallet } from '@/store/wallet';

type Prop = {
  data: ListedTokenResponse;
};

const backend = new ZilPayBackend();
const dex = new DragonDex();
export const PagePool: NextPage<Prop> = (props) => {
  const { t } = useTranslation(`pool`);

  const wallet = useStore($wallet);

  const [loading, setLoading] = React.useState(true);

  const hanldeUpdate = React.useCallback(async() => {
    if (typeof window !== 'undefined') {
      setLoading(true);
      try {
        await dex.updateState();
      } catch {
        ///
      }
      setLoading(false);
  }
  }, []);

  React.useEffect(() => {
    if (props.data) {
      updateDexPools(props.data.pools);
      updateRate(props.data.rate);
      loadFromServer(props.data.tokens.list);
    }
  }, [props]);

  React.useEffect(() => {
    if (wallet) {
      hanldeUpdate();
    }
  }, [hanldeUpdate, wallet]);

  return (
    <div className={styles.container}>
      <Head>
        <title>{t('overview.head')}</title>
        <meta
          property="og:title"
          content={t('overview.head')}
          key="title"
        />
      </Head>
      <div>
        <PoolOverview loading={loading}/>
      </div>
    </div>
  );
};

export const getServerSideProps = async (context: GetServerSidePropsContext) => {
  if (context.res) {
    // res available only at server
    // no-store disable bfCache for any browser. So your HTML will not be cached
    context.res.setHeader(`Cache-Control`, `no-store`);
  }

  const data = await backend.getListedTokens();

  updateDexPools(data.pools);
  updateRate(data.rate);
  loadFromServer(data.tokens.list);

  return {
    props: {
      data,
      ...await serverSideTranslations(context.locale || `en`, [`pool`, `common`])
    }
  };
};

export default PagePool;

```

`zilpay.io/pages/swap.tsx`:

```tsx
import styles from '@/styles/pages/swap.module.scss';

import type { ListedTokenResponse } from '@/types/token';
import type { SwapPair } from '@/types/swap';

import { useTranslation } from 'next-i18next';
import Head from 'next/head';
import React from 'react';
import { GetServerSidePropsContext, NextPage } from 'next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';

import { SwapForm } from '@/components/swap-form';

import { DragonDex } from '@/mixins/dex';
import { ZilPayBackend } from '@/mixins/backend';
import { updateRate } from '@/store/settings';
import { updateDexPools } from '@/store/shares';
import { loadFromServer } from '@/store/tokens';
import { useStore } from 'react-stores';
import { $wallet } from '@/store/wallet';

type Prop = {
  data: ListedTokenResponse;
  pair: SwapPair[];
};

const dex = new DragonDex();
const backend = new ZilPayBackend();
export const PageSwap: NextPage<Prop> = (props) => {
  const { t } = useTranslation(`swap`);

  const wallet = useStore($wallet);

  const hanldeUpdate = React.useCallback(async() => {
    if (typeof window !== 'undefined') {
      updateRate(props.data.rate);

      try {
        await dex.updateTokens();
        await dex.updateState();
      } catch {
        ///
      }
    }
  }, [props]);

  React.useEffect(() => {
    if (props.data) {
      updateDexPools(props.data.pools);
      updateRate(props.data.rate);
      loadFromServer(props.data.tokens.list);
    }
  }, [props]);

  React.useEffect(() => {
    if (wallet) {
      hanldeUpdate();
    }
  }, [hanldeUpdate, wallet]);

  return (
    <div className={styles.container}>
       <Head>
        <title>{t('head_title')}</title>
        <meta
          property="og:title"
          content={t('head_title')}
          key="title"
        />
      </Head>
      <div>
        <SwapForm startPair={props.pair}/>
      </div>
    </div>
  );
}

export async function getServerSideProps(context: GetServerSidePropsContext) {
  if (context.res) {
    // res available only at server
    // no-store disable bfCache for any browser. So your HTML will not be cached
    context.res.setHeader(`Cache-Control`, `no-store`);
  }

  const data = await backend.getListedTokens();
  let pair = [
    {
      value: '0',
      meta: data.tokens.list[0]
    },
    {
      value: '0',
      meta: data.tokens.list[1]
    }
  ];

  if (context.query) {
    if (context.query['tokenIn']) {
      const found = data.tokens.list.find((t) => t.bech32 === context.query['tokenIn']);
      if (found) {
        pair[0].meta = found;
      }
    }

    if (context.query['tokenOut']) {
      const found = data.tokens.list.find((t) => t.bech32 === context.query['tokenOut']);
      if (found) {
        pair[1].meta = found;
      }
    }
  }

  updateDexPools(data.pools);
  updateRate(data.rate);
  loadFromServer(data.tokens.list);

  return {
    props: {
      data,
      pair,
      ...(await serverSideTranslations(context.locale || `en`, [`swap`, `common`]))
    }
  };
}

export default PageSwap;

```

`zilpay.io/pages/terms.tsx`:

```tsx
import styles from '@/styles/pages/policy.module.scss';

import React from 'react';
import Head from 'next/head';

import { useTranslation } from 'next-i18next';
import { GetServerSidePropsContext, NextPage } from 'next';
import { serverSideTranslations } from 'next-i18next/serverSideTranslations';

export const TermsPage: NextPage = () => {
  const { t } = useTranslation(`terms`);

  return (
    <div className={styles.terms}>
      <div className={styles.dummy} />
      <Head>
        <title>{t(`head_title`)}</title>
        <meta
          property="og:title"
          content={t(`head_title`)}
          key="title"
        />
      </Head>
      <div className={styles.wrapper}>
        <p className={styles.muted}>
          {t(`last_update`)}
        </p>
        <h1>
          {t(`title`)}
        </h1>
        <p>
          <strong>
            {t(`sub_title0`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p0`)}
        </p>
        <p className={styles.muted}>
          {t(`p1`)}
        </p>
        <p className={styles.muted}>
          {t(`p2`)}
        </p>
        <p className={styles.muted}>
          {t(`p3`)}
        </p>
        <p className={styles.muted}>
          {t(`p4`)}
        </p>
        <p>
          <strong>
            {t(`subt_title1`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p5`)}
        </p>
        <p className={styles.muted}>
          {t(`p6`)}
        </p>
        <p>
          <strong>
            {t(`subt_title2`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p6`)}
        </p>
        <p className={styles.muted}>
          {t(`p7`)}
        </p>
        <p className={styles.muted}>
          {t(`p8`)}
        </p>
        <p className={styles.muted}>
          {t(`p9`)}
        </p>
        <p className={styles.muted}>
          {t(`p10`)}
        </p>
        <p>
          <strong>
            {t(`subt_title3`)}
          </strong>
        </p>
        <p>
          <strong>
            {t(`subt_title4`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p11`)}
        </p>
        <p>
          <strong>
            {t(`subt_title5`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p12`)}
        </p>
        <p>
          <strong>
            {t(`subt_title6`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p13`)}
        </p>
        <p>
          <strong>
            {t(`subt_title7`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p14`)}
        </p>
        <p>
          <strong>
            {t(`subt_title8`)}
          </strong>
        </p>
        <p>
          <strong>
            {t(`subt_title9`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p15`)}
        </p>
        <p className={styles.muted}>
          {t(`p16`)}
        </p>
        <p className={styles.muted}>
          {t(`p17`)}
        </p>
        <p>
          <strong>
            {t(`subt_title10`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p18`)}
        </p>
        <p>
          <strong>
            {t(`subt_title11`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p19`)}
        </p>
        <p>
          <strong>
            {t(`subt_title12`)}
          </strong>
        </p>
        <p>
          <strong>
            {t(`subt_title13`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p20`)}
        </p>
        <p className={styles.muted}>
          {t(`p21`)}
        </p>
        <p>
          <strong>
            {t(`subt_title14`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p22`)}
        </p>
        <p className={styles.muted}>
          {t(`p23`)}
        </p>
        <p>
          <strong>
            {t(`subt_title15`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p24`)}
        </p>
        <p className={styles.muted}>
          {t(`p25`)}
        </p>
        <p className={styles.muted}>
          {t(`p26`)}
        </p>
        <p>
          <strong>
            {t(`subt_title16`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p27`)}
        </p>
        <p>
          <strong>
            {t(`subt_title17`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p28`)}
        </p>
        <p className={styles.muted}>
          {t(`p29`)}
        </p>
        <p>
          <strong>
            {t(`subt_title18`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p30`)}
        </p>
        <p>
          <strong>
            {t(`subt_title19`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p31`)}
        </p>
        <p>
          <strong>
            {t(`subt_title20`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p32`)}
        </p>
        <p>
          <strong>
            {t(`subt_title21`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p33`)}
        </p>
        <p>
          <strong>
            {t(`subt_title22`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p34`)}
        </p>
        <p>
          <strong>
            {t(`subt_title23`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p35`)}
        </p>
        <p>
          <strong>
            {t(`subt_title24`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p36`)}
        </p>
        <p className={styles.muted}>
          {t(`p37`)}
        </p>
        <p className={styles.muted}>
          {t(`p38`)}
        </p>
        <p>
          <strong>
            {t(`subt_title25`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p39`)}
        </p>
        <p className={styles.muted}>
          {t(`p40`)}
        </p>
        <p>
          <strong>
            {t(`subt_title26`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p41`)}
        </p>
        <p className={styles.muted}>
          {t(`p42`)}
        </p>
        <p>
          <strong>
            {t(`subt_title27`)}
          </strong>
        </p>
        <p className={styles.muted}>
          <strong>
            {t(`subt_title28`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p43`)}
        </p>
        <p className={styles.muted}>
          {t(`p44`)}
        </p>
        <p>
          <strong>
            {t(`subt_title29`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p45`)}
        </p>
        <p>
          <strong>
            {t(`subt_title30`)}
          </strong>
        </p>
        <p className={styles.muted}>
          {t(`p46`)}
        </p>
      </div>
    </div>
  );
};

export const getStaticProps = async (props: GetServerSidePropsContext) => ({
    props: {
      ...await serverSideTranslations(props.locale || `en`, [`terms`, `common`]),
    },
  });

export default TermsPage;

```

`zilpay.io/store/dex.ts`:

```ts
import { ZERO_ADDR } from '@/config/conts';
import { Store } from 'react-stores';

const init = {
  lp: BigInt("1000000000000000"),
  fee: BigInt("9970"),
  protoFee: BigInt(500),
  rewardsPool: ZERO_ADDR
}
export const $dex = new Store(init);

```

`zilpay.io/store/netwrok.ts`:

```ts
import { NET } from '@/config/conts';
import { Store } from 'react-stores';

const init: {
  net: 'mainnet' | 'testnet' | 'private' | string;
} = {
  net: NET
}
export const $net = new Store(init);

```

`zilpay.io/store/settings.ts`:

```ts
import { BLOCKS, SLIPPAGE } from '@/config/conts';
import { StorageFields } from '@/config/storage-fields';
import { Themes } from '@/config/themes';
import { Store } from 'react-stores';
import cookieCutter from 'cookie-cutter';

const initState = {
  rate: Number(0),
  slippage: SLIPPAGE,
  blocks: BLOCKS,
  theme: String(Themes.Dark)
};

try {
  if (window.__NEXT_DATA__.props.pageProps.theme) {
    initState.theme = window.__NEXT_DATA__.props.pageProps.theme;
  }

  if (window.__NEXT_DATA__.props.pageProps.data.rate) {
    initState.rate = Number(window.__NEXT_DATA__.props.pageProps.data.rate || 0);
  }
} catch {
  ///
}

export const $settings = new Store(initState);

export function updateSettingsStore(data: typeof initState) {
  $settings.setState(data);

  if (typeof window !== 'undefined') {
    cookieCutter.set('theme', data.theme, {
      path: '/'
    });

    window.document.body.setAttribute('theme-color', data.theme);
    window.localStorage.setItem(StorageFields.Settings, JSON.stringify($settings.state));
  }
}

export function updateRate(rate: number) {
  initState.rate = rate;
  $settings.setState({
    ...$settings.state,
    rate
  });
}

export function updateFromStorage() {
  try {
    const data = window.localStorage.getItem(StorageFields.Settings);
    const theme = cookieCutter.get('theme') || Themes.Dark;

    if (data) {
      $settings.setState({
        ...JSON.parse(data),
        theme,
        rate: initState.rate
      });
    } else {
      $settings.setState({
        ...$settings.state,
        theme,
        rate: initState.rate
      });
    }
    window.document.body.setAttribute('theme-color', $settings.state.theme);
  } catch {
    /////
  }
}

```

`zilpay.io/store/shares.ts`:

```ts
import type { Share, DexPool, FiledBalances } from '@/types/zilliqa';
import type { ListedTokenResponse } from '@/types/token';

import { StorageFields } from '@/config/storage-fields';

import { Store } from 'react-stores';

const init: {
  shares: Share,
  pools: DexPool,
  balances: FiledBalances
} = {
  shares: {},
  pools: {},
  balances: {}
};

try {
  const cache = window.__NEXT_DATA__.props.pageProps.data as ListedTokenResponse;

  if (cache && cache.pools) {
    init.pools = cache.pools;
  }
} catch {
  // console.warn(err);
}

export const $liquidity = new Store(init);

function cacheState() {
  if (typeof window !== 'undefined') {
    const serialized = JSON.stringify($liquidity.state, (_, v) => typeof v === 'bigint' ? v.toString() : v);
    window.localStorage.setItem(StorageFields.Liquidity, serialized);
  }
}

export function updateLiquidity(shares: Share, pools: DexPool) {
  $liquidity.setState({
    pools,
    shares
  });

  cacheState();
}

export function updateShares(shares: Share) {
  $liquidity.setState({
    ...$liquidity.state,
    shares
  });

  cacheState();
}

export function updateDexPools(pools: DexPool) {
  $liquidity.setState({
    ...$liquidity.state,
    pools
  });

  cacheState();
}

export function updateDexBalances(balances: FiledBalances) {
  $liquidity.setState({
    ...$liquidity.state,
    balances
  });

  cacheState();
}

```

`zilpay.io/store/tokens.ts`:

```ts
import type { ListedTokenResponse, Token, TokenState } from 'types/token';

import { Store } from 'react-stores';

// import { StorageFields } from '@/config/storage-fields';

let initState: {
  tokens: Token[]
} = {
  tokens: []
};

if (typeof window !== 'undefined' && window.__NEXT_DATA__.props) {
  try {
    const listedTokens = window.__NEXT_DATA__.props.pageProps.data as ListedTokenResponse;

    if (listedTokens && listedTokens.tokens.list && listedTokens.tokens.list.length > 0) {
      initState.tokens = listedTokens.tokens.list.map((meta) => ({
        meta,
        balance: {}
      }));
    }
  } catch (err) {
    console.warn(err);
  }
}

export const $tokens = new Store(initState);

export function addToken(token: Token) {
  const has = $tokens.state.tokens.some((t) => token.meta.base16 === t.meta.base16);

  if (has) {
    throw new Error('Token already has');
  }

  const tokens = [...$tokens.state.tokens, token];
  $tokens.setState({
    tokens
  });
}

export function updateTokens(tokens: Token[]) {
  const newTokens = $tokens.state.tokens.map((token) => {
    const found = tokens.find((t) => t.meta.base16 === token.meta.base16);

    if (found) {
      token.balance = found.balance;
    }

    return token;
  });

  $tokens.setState({
    tokens: newTokens
  });
}

export function loadFromServer(listedTokens: TokenState[]) {
  if (listedTokens && listedTokens.length > 0) {
    const list: Token[] = listedTokens.map((t) => ({
      balance: {},
      meta: t
    }));
    const state = {
      tokens: list
    };
  
    $tokens.setState(state);
  }
}

```

`zilpay.io/store/transactions.ts`:

```ts
import type { Tx } from 'types/zilliqa';

import { Store } from 'react-stores';
import { LIMIT } from '@/config/conts';

const initState: {
  transactions: Tx[]
} = {
  transactions: []
};

export const $transactions = new Store(initState);

export function addTransactions(payload: Tx) {
  const { transactions } = $transactions.state;
  const newState = [payload, ...transactions];

  if (newState.length >= LIMIT) {
    newState.pop();
  }

  $transactions.setState({
    transactions: newState
  });

  window.localStorage.setItem(payload.from, JSON.stringify($transactions.state));
}

export function updateTransactions(from: string, transactions: Tx[]) {
  $transactions.setState({
    transactions
  });

  window.localStorage.setItem(from, JSON.stringify($transactions.state));
}

export function resetTransactions(from: string) {
  window.localStorage.removeItem(from);
  $transactions.resetState();
}
```

`zilpay.io/store/wallet.ts`:

```ts
import type { Wallet } from '@/types/wallet';

import { Store } from 'react-stores';

export const $wallet = new Store<Wallet | null>(null);

```

`zilpay.io/types/index.d.ts`:

```ts
declare module 'cookie-cutter';
declare module 'toformat';

```

`zilpay.io/types/swap.d.ts`:

```ts
import type { TokenState } from "./token";

export interface SwapPair {
  value: string;
  meta: TokenState;
}

```

`zilpay.io/types/token.d.ts`:

```ts
export interface TokenState {
  decimals: number;
  bech32: string;
  base16: string;
  name: string;
  symbol: string;
  scope: number;
}

export interface Token {
  balance: {
    [owner: string]: string;
  };
  meta: TokenState;
}

export interface ParamItem {
  type: string;
  value: string | unknown[];
  vname: string;
}

export interface ListedTokenResponse {
  tokens: {
    list: TokenState[];
    count: number;
  };
  pools: {
    [token: string]: string[];
  };
  rate: number;
}

```

`zilpay.io/types/wallet.d.ts`:

```ts
export interface Wallet {
  base16: string;
  bech32: string;
}

```

`zilpay.io/types/zilliqa.d.ts`:

```ts
export interface RPCResponse {
  id: number;
  jsonrpc: string;
  result?: any;
  error?: {
    code: number;
    data: unknown;
    message: string;
  };
};

export interface Tx {
  hash: string;
  name: string;
  from: string;
  timestamp: number;
  confirmed: boolean;
  error?: boolean;
}

export interface FiledBalances {
  [token: string]: {
    [owner: string]: string;
  }
}

export interface Share {
  [token: string]: bigint;
}


export interface DexPool {
  [token: string]: string[];
}

export interface FiledPools {
  [token: string]: {
    argtypes: string[];
    arguments: string[];
    constructor: "Pair";
  }
}

export interface FieldTotalContributions {
  [token: string]: string;
}

```